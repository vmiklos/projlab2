= Project laboratory log

== 1st week

I'm trying to find some documentation on dm-mirror. First, it's a Linux kernel
module and it's part of the vanilla kernel. It was already available on my
system:

----
$ /sbin/modinfo dm-mirror
filename:       /lib/modules/2.6.35-fw2/kernel/drivers/md/dm-mirror.ko
license:        GPL
author:         Joe Thornber
description:    device-mapper mirror target
srcversion:     AC2B91EB6F0EF6E46524514
depends:        dm-region-hash,dm-mod,dm-log
vermagic:       2.6.35-fw2 SMP preempt mod_unload modversions ELAN 
----

The first hit for "dm-mirror" on Google was a bugreport on the device-mapper
development mailing list, so I guess it does not have a separate homepage. The
device-mapper project is about the userspace part. It's homepage is
http://sourceware.org/dm/, but that has been recently merged to the lvm2
project: http://sources.redhat.com/lvm2/.

Digging further the search result, I found a
http://www.tldp.org/HOWTO/LVM-HOWTO/[HOWTO on TLDP] from 2006, which looks like
a good initial overview in this area, even if it may be a bit outdated. At
least it http://www.tldp.org/HOWTO/LVM-HOWTO/anatomy.html[explains] the various
PV/VG/LV/FS concepts with a nice asciiart.

Regarding motivation, I found this page:
http://rhn.redhat.com/errata/RHBA-2009-0967.html, it's clear that lvm2 has many
areas where it can be improved. ;)

I'm not sure, but maybe the lvm2 is a generic package and the real lvm-based
raid userspace support is provided by dmraid:
http://people.redhat.com/heinzm/sw/dmraid/

Finally I found step-by-step mirror-specific LVM howto:
http://www.tcpdump.com/kb/os/linux/lvm-mirroring/intro.html.

Using that, I did the followings to set up a test LVM mirror in vmware:

I created a virtual machine: 4 physical disks:

----
# fdisk -l 2>/dev/null|grep ^Disk.*MB
Disk /dev/sda: 8589 MB, 8589934592 bytes
Disk /dev/sdb: 1073 MB, 1073741824 bytes
Disk /dev/sdc: 1073 MB, 1073741824 bytes
Disk /dev/sdd: 1073 MB, 1073741824 bytes
----

I installed a Frugalware Linux 1.3 base system (kernel 2.6.35) on the first one
(sda1, using the whole disk), this root filesystem is a normal ext4 partiton

I installed the lvm2 package, created PV-s on the other 3 disks:

----
# pvcreate /dev/sdb /dev/sdc /dev/sdd
  Physical volume "/dev/sdb" successfully created
  Physical volume "/dev/sdc" successfully created
  Physical volume "/dev/sdd" successfully created
----

Then I created the VG:

----
# vgcreate myvg /dev/sdb                  
  /proc/devices: No entry for device-mapper found
  Volume group "myvg" successfully created
# vgextend myvg /dev/sdc
  /proc/devices: No entry for device-mapper found
  Volume group "myvg" successfully extended
# vgextend myvg /dev/sdd
  /proc/devices: No entry for device-mapper found
  Volume group "myvg" successfully extended
----

I eliminated the warning my loading the dm-mirror module:

----
# modprobe dm-mirror
# vgreduce myvg /dev/sdd
  Removed "/dev/sdd" from volume group "myvg"
# vgextend myvg /dev/sdd
  Volume group "myvg" successfully extended
----

Let's see the PV and VG status before creating an LV:

----
# pvs
  PV         VG     Fmt  Attr PSize    PFree   
  /dev/sdb   myvg-b lvm2 a-   1020.00m 1020.00m
  /dev/sdc   myvg-c lvm2 a-   1020.00m 1020.00m
  /dev/sdd   myvg-d lvm2 a-   1020.00m 1020.00m
# vgs
  VG     #PV #LV #SN Attr   VSize    VFree   
  myvg-b   1   0   0 wz--n- 1020.00m 1020.00m
  myvg-c   1   0   0 wz--n- 1020.00m 1020.00m
  myvg-d   1   0   0 wz--n- 1020.00m 1020.00m
----

I created the lvm mirror (the only real difference to a normal LV is the -m 1
option):

----
# lvcreate -L 900M -n mymirror -m 1 myvg 
  Logical volume "mymirror" created
----

Now let's see the status again:

----
# pvs
  PV         VG   Fmt  Attr PSize    PFree   
  /dev/sdb   myvg lvm2 a-   1020.00m  120.00m
  /dev/sdc   myvg lvm2 a-   1020.00m  120.00m
  /dev/sdd   myvg lvm2 a-   1020.00m 1016.00m
# vgs
  VG   #PV #LV #SN Attr   VSize VFree
  myvg   3   1   0 wz--n- 2.99g 1.23g
# lvs
  LV       VG   Attr   LSize   Origin Snap%  Move Log           Copy%  Convert
  mymirror myvg mwi-a- 900.00m                    mymirror_mlog 100.00        
----

- LVS can even show which part of the mirror (one and the other side + log
  device) is located on which device:

----
# lvs -a -o +devices
  LV                  VG   Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  mymirror            myvg mwi-a- 900.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg iwi-ao 900.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg iwi-ao 900.00m                                                 /dev/sdc(0)                              
  [mymirror_mlog]     myvg lwi-ao   4.00m                                                 /dev/sdd(0)     
----

The device nodes are created as well:

----
# ls /dev/mapper
control  myvg-mymirror  myvg-mymirror_mimage_0  myvg-mymirror_mimage_1  myvg-mymirror_mlog
----

Finally I did the usual format/mount/check-free-space:

----
# mkfs.ext4 /dev/mapper/myvg-mymirror
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
57600 inodes, 230400 blocks
11520 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=239075328
8 block groups
32768 blocks per group, 32768 fragments per group
7200 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 23 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
# mkdir /mnt/mirror
# mount /dev/mapper/myvg-mymirror /mnt/mirror
# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda1             7.9G  843M  6.7G  12% /
/dev/mapper/myvg-mymirror
                      886M   18M  824M   3% /mnt/mirror
----

Questions / TODOs:

- The log device is not redundant, is that expected?

Looks like that wasn't supported for a long time, the changelog says:

-----
Version 2.02.63 - 14th April 2010
  (...)
  Add ability to create mirrored logs for mirror LVs.
  (...)
----

- Gabor said that the current read strategy is an RR-based algorithm, I need to
  find out how to verify that.

- Is there anything fundamentally wrong in the steps I used for creating a dm-mirror?

- What would be the goals for the end of the semester? A simple goal I can
  think of is to first verify that currently one can't specify which PV is the
  preferred one when reading from dm-mirrors and if that's true, implement a way
  to be able to do so.

== 2nd week

Bookmarks from last week:

- http://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/5/html-single/Cluster_Logical_Volume_Manager/index.html#mirrored_volumes
- http://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/5/html-single/Cluster_Logical_Volume_Manager/index.html#LV_create

=== Part1: Installing RHEL, building dm-mirror

First I installed a RHEL Server 5.5 in VMware. (Nothing special, I disabled the
graphical part and enabled all development-related packages.) After
installation, my goal was to build the dm-mirror kernel module, so that I can
modify it. I did the followings:

----
$ cd ~
$ mkdir -p rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
$ echo '%_topdir %(echo $HOME)/rpmbuild' > .rpmmacros
$ curl -I ftp://ftp.redhat.com/redhat/linux/enterprise/5Server/en/os/SRPMS/kernel-2.6.18-194.11.4.el5.src.rpm
Last-Modified: Mon, 20 Sep 2010 09:21:47 GMT
(...)
$ wget ftp://ftp.redhat.com/redhat/linux/enterprise/5Server/en/os/SRPMS/kernel-2.6.18-194.11.4.el5.src.rpm
$ rpm -Uvh kernel-2.6.18-194.11.4.el5.src.rpm 2>&1 | grep -v mockb
----

To unpack and prepare (patch) the sources:

----
$ cd ~/rpmbuild/SPECS
$ rpmbuild -bp --target=`uname -m` kernel-2.6.spec 2> prep-err.log | tee prep-out.log
----

To build the dm-mirror module (the symvers part is necessary otherwise the
kernel will become tainted when the module is loaded):

----
$ cd ~/rpmbuild/BUILD/kernel-2.6.18/linux-2.6.18.i686
$ perl -p -i -e "s/^EXTRAVERSION.*/EXTRAVERSION = -194.el5/" Makefile

$ cp /boot/symvers-2.6.18-194.el5.gz .
$ gunzip symvers-2.6.18-194.el5.gz
$ mv symvers-2.6.18-194.el5 Module.symvers

$ make prepare
$ make modules_prepare
$ make M=drivers/md
# cp drivers/md/*.ko /lib/modules/2.6.18-194.el5/extra
# depmod -a
----

Only the last 3 commands has to be executed after each source code
modification.

Reloading the module can't be done without stopping the lvm mirror first:

----
# lvchange -a n myvg/mymirror
# rmmod dm-mirror
# modprobe dm-mirror
# lvchange -a y myvg/mymirror
----

I tried adding a sample modification:

- installed Git from EPEL
- added sources files under drivers/md to git
- added a debug printf to the init function of the dm_mirror module:

----
diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
index 23c1d65..70cb224 100644
--- a/drivers/md/dm-raid1.c
+++ b/drivers/md/dm-raid1.c
@@ -1936,6 +1936,8 @@ static int __init dm_mirror_init(void)
 {
        int r;
 
+       printk("debug, dm-mirror init\n");
+
        _dm_raid1_read_record_cache = kmem_cache_create("bio_map_info",
                                sizeof(struct bio_map_info), 0, 0, NULL, NULL);
        if (!_dm_raid1_read_record_cache) {
----

And yes, after building, installing and reloading the module, the string
appeared in dmesg. :)

Used documentation:

- http://fedoraproject.org/wiki/EPEL/FAQ#howtouse
- http://wiki.centos.org/HowTos/BuildingKernelModules

=== Part 2: creating the LVM mirror

This was not necessary, the LVM mirror I created last week was recognized
automatically. (The mirror uses sdb, sdc and sdd, the system is on sda, so I
just the contents of sda during the installation of RHEL.)

=== Part 3: more documentation, questions

So after setting up the new build environment, I looked at the documentation
links Ivan provided.

I read the following pages:

- http://sources.redhat.com/lvm2/wiki/FeatureRequests/dm/mirroring

My note: This list is a bit confusing, it's not exactly clear what's
implemented and what is not. "Ability to handle device failures" is, not, sure
about the rest.

- http://sources.redhat.com/lvm2/wiki/MirrorDesignV1

Most important infos:

- state: clean, dirty (written and not yet synced), not-in-sync (the mirror device failed)
- current algorithm: round-robin - change device after every 128 requests
- log: can be different for each LV: core and device implementations
- trade-offs:

  * core (fast write, slow startup) vs device (slow write, fast startup)
  * region size: big (small log, lot of data to recover) vs small (large log, small amount of data to recover)

- handling failures:

  * reads: just try an other device
  * write: raise an event, then the userspace 'dmeventd' can handle them

My note: so the read algorithm is hardwired, but the log one can be configured
for each LV, something similar could be done for read algorithm as well to make
it configurable. If I remember correctly, Gabor was referring to make this
configurable at a global level via sysctl. That has the benefit of not changing
the LVM metadata, I guess.

Reading the code a bit, it turns out that a set of mirrors is stored in the
'mirror_set' struct and that has an array of 'mirrors' and a 'default_mirror'
pointer. So the code is already aware that from the N devices there is a
default one, just it's not possible to always read from there.

- http://sources.redhat.com/lvm2/wiki/MirrorDesignV2-discussion

This one is a bit confusing as well, as far as I see for example the "Ability
to have at least two log devices to avoid single point of log device failure.
The log devices can be used in replicated mode or hot/spare standby mode."
problem is already solved. (See 1st week, in LVM2 version 2.02.63.)

Other than that, I think the features mentioned here would be nice, just need
to check what is implemented and what is not.

=== Summary

This week I spent time on creating the development environment and
understanding current issues of dm-mirror. If that's OK with Ivan, that next
week (as a first task) I would try to add support of changing the read method
globally (via sysctl) so the user could choose between the current 'RR' method
and a new 'always read from the default mirror' one. Once this is completed, a
second step could be to turns this global setting a to per-LV setting, like one
can use '--corelog' when creating mirrored LV's to use an in-memory log device
instead of a physical one. Does this sound like a good direction?

Other question: in case I start the actual coding, how should I track / share
my changes? For now I just created a local git repo, but:

- Is there a git repo for the RHEL kernel I can clone? Or is it ok that I just
  create my own repo and once a feature is ready, we can squash all commits
  from that repo to a single patch, like the other huge patches in the kernel
  SRPM? (And even if that's the case, I found the git repo of Fedora's kernel
  at git://pkgs.fedoraproject.org/kernel, but I did not found somethething
  similar for RHEL - is it the best if I just stick to the kernel SRPM I
  downloaded today?)
- Where should I share my code? Is it OK if I push it to a public hosting site
  like gitorious.org or do you have a preference?

== 3rd week

=== Clarifications

----
> In Part 1:
> 
> you did a curl and a wget. Why were both of them necesary?
----

I used curl only for documentation purposes to show the date of the SRPM.

----
> In Part 3:
> 
> Where can you see this problem is solved? How do you make the log device to be used in replicated mode?
----

I haven't tried it myself, I just had a look at a recent lvm2 release (LVM2.2.02.73.tgz), in particual its WHATS_NEW file. In the 'Version 2.02.63' section, there is a line:

----
Add ability to create mirrored logs for mirror LVs.
----

I guess that means it's finally possible to avoid the single point of failure
regarding the log device. Or did I misunderstand something?

----
> Yes it does. There is one thing I'm missing here though: how do you choose the default mirror?
----

From the code, it seems that the 'default_mirror' pointer of rht 'mirror_set'
structure just always points to the first item in the set. So by defaul it
would be the first, then the user could change it if it's needed. (See below.)

----
> I think the sysctl global read method changing is a good first step.
> Once you are ready with that, it would be good to try it and prove it works as expected.
> As the second step, I would like to invite you to see about how to choose the default mirror.
> Then, the third step can be a per-mapping setting for the read method.
> (I refer to it as per-mapping instead of per-LV to stress it works in the device mapper to achieve the mirroring.)
> I would make this initially also a runtime setting, so as to avoid the need for changing the LVM metadata headers.
> 
> Is this ok with you?
----

Yes, that sounds fine.

----
> I need to think about this one. Once you have some working code, we would of course like to see it.
----

OK, I'll then keep the repo private for now, then you can decide where should I publish it.

=== Goals

Summary of the above:

- sysctl global setting + proove that it works
- see about how to choose the default mirror
- per-mapping setting for the read method (first just runtime to avoid metadata change)

=== Adding the sysctl global setting

A simple idea is to allow having the RR IO number (which is 128 by default and
has to be > 1 at the moment) as 0, which would mean reading only from the
default mirror. This code seems to be in drivers/md/dm-raid1.c. The
mirror_message() function can set this default 128 value when it receives a
message. After some searching, the userspace command to send messages to the
target is like this:

----
# dmsetup message myvg-mymirror 0 io_balance round_robin ios 128
----

Right now the "io_balance round_robin ios" part is fixed, and then the 4th
argument is the new value. But this can be extended to set different
properties, so I think it's a good idea to use this method (given that it's
already there + it's already device-specific) instead of sysctl.

The 'mirror_set' struct has two values for the io numbers: the 'rr_ios_set' is
the adjustable default, the 'rr_ios' is the current value (which is constantly
decremented after each read). The RR algorithm is done implemented in the
choose_mirror() function: the 'read_mirror' pointer is constantly decremented
and in case it would become invalid, it's moved to the end of the array again.

So what I did is:

- allow setting rr_ios_set value to 0
- in case rr_ios_set is 0, the ignore rr_ios and just return default_mirror in
  choose_mirror() (default_mirror is actually the first element of the mirror
  array at the moment, so there isn't any intelligent algorithm there to find out
  what would be a good default)
- added debug printk() to see which mirror is used

To build, install, and reload the kernel module, I defined:

----
$ alias build="make M=drivers/md"
$ alias install="sudo cp drivers/md/*.ko /lib/modules/2.6.18-194.el5/extra && sudo depmod -a"
$ alias reload="sudo sh -c '/usr/sbin/lvchange -a n myvg/mymirror; /sbin/rmmod dm-mirror; /sbin/modprobe dm-mirror; /usr/sbin/lvchange -a y myvg/mymirror'"
----

Then I just mounted /dev/mapper/myvg-mymirror to /mnt/mirror, that performs a
few reads already, just enough for quick testing.

dmesg output with rr_ios_set = 4:

----
device-mapper: raid1: Setting round robin read ios for "253:5" to 4
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
----

dmesg output with rr_ios_set = 0:

----
device-mapper: raid1: Setting round robin read ios for "253:5" to 0
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
----

(The first patch implements this.)

=== Choosing the default mirror

Now that I think about it - I think that's something that probably the user
wants to decide. Our use case was that one disk is local and the other is
remote, so a trivial solution is to add some interface where the user can set
what's the preferred one.

So for example, let's say sdb is local and sdc is remote. We get the LV name from lvs:

----
# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38G                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00M                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-ao 900.00M                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       iwi-ao 900.00M                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       iwi-ao 900.00M                                                 /dev/sdc(0)                              
  [mymirror_mlog]     myvg       lwi-ao   4.00M                                                 /dev/sdd(0)   
----

Then we can use dmsetup to get the numbers of mymirror_mimage_0:

----
# dmsetup ls
myvg-mymirror   (253, 5)
myvg-mymirror_mlog      (253, 2)
VolGroup00-LogVol01     (253, 1)
myvg-mymirror_mimage_1  (253, 4)
VolGroup00-LogVol00     (253, 0)
myvg-mymirror_mimage_0  (253, 3)
----

Finally send a message to set it as default:

----
# dmsetup message myvg-mymirror 0 io_balance default 253:3
----

dmesg output when the default device is 253:3:

----
device-mapper: raid1: Setting round robin read ios for "253:5" to 0
device-mapper: raid1: Setting default device for "253:5" to "253:3"
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
----

dmesg output when the default device is 253:4:

----
device-mapper: raid1: Setting default device for "253:5" to "253:4"
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
----

(The second patch implements this.)

=== Per-mapping setting for the read method

The idea is to use dmesetup messages instead of sysctl and in this case the
setting is already per-mapping.

=== Plans

Next week it would be nice to do some measurements, though right now I have no
idea how could we emulate a slow and a fast disk to show that in some cases
avoiding RR can cause a speedup.

Also, is it enough do be able to choose default mirror like this, or maybe we
could introduce some algorithm here as well?

So I'm open to ideas on what to do next.
