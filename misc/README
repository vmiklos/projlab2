= Project laboratory log

== 1st week

I'm trying to find some documentation on dm-mirror. First, it's a Linux kernel
module and it's part of the vanilla kernel. It was already available on my
system:

----
$ /sbin/modinfo dm-mirror
filename:       /lib/modules/2.6.35-fw2/kernel/drivers/md/dm-mirror.ko
license:        GPL
author:         Joe Thornber
description:    device-mapper mirror target
srcversion:     AC2B91EB6F0EF6E46524514
depends:        dm-region-hash,dm-mod,dm-log
vermagic:       2.6.35-fw2 SMP preempt mod_unload modversions ELAN 
----

The first hit for "dm-mirror" on Google was a bugreport on the device-mapper
development mailing list, so I guess it does not have a separate homepage. The
device-mapper project is about the userspace part. It's homepage is
http://sourceware.org/dm/, but that has been recently merged to the lvm2
project: http://sources.redhat.com/lvm2/.

Digging further the search result, I found a
http://www.tldp.org/HOWTO/LVM-HOWTO/[HOWTO on TLDP] from 2006, which looks like
a good initial overview in this area, even if it may be a bit outdated. At
least it http://www.tldp.org/HOWTO/LVM-HOWTO/anatomy.html[explains] the various
PV/VG/LV/FS concepts with a nice asciiart.

Regarding motivation, I found this page:
http://rhn.redhat.com/errata/RHBA-2009-0967.html, it's clear that lvm2 has many
areas where it can be improved. ;)

I'm not sure, but maybe the lvm2 is a generic package and the real lvm-based
raid userspace support is provided by dmraid:
http://people.redhat.com/heinzm/sw/dmraid/

Finally I found step-by-step mirror-specific LVM howto:
http://www.tcpdump.com/kb/os/linux/lvm-mirroring/intro.html.

Using that, I did the followings to set up a test LVM mirror in vmware:

I created a virtual machine: 4 physical disks:

----
# fdisk -l 2>/dev/null|grep ^Disk.*MB
Disk /dev/sda: 8589 MB, 8589934592 bytes
Disk /dev/sdb: 1073 MB, 1073741824 bytes
Disk /dev/sdc: 1073 MB, 1073741824 bytes
Disk /dev/sdd: 1073 MB, 1073741824 bytes
----

I installed a Frugalware Linux 1.3 base system (kernel 2.6.35) on the first one
(sda1, using the whole disk), this root filesystem is a normal ext4 partiton

I installed the lvm2 package, created PV-s on the other 3 disks:

----
# pvcreate /dev/sdb /dev/sdc /dev/sdd
  Physical volume "/dev/sdb" successfully created
  Physical volume "/dev/sdc" successfully created
  Physical volume "/dev/sdd" successfully created
----

Then I created the VG:

----
# vgcreate myvg /dev/sdb                  
  /proc/devices: No entry for device-mapper found
  Volume group "myvg" successfully created
# vgextend myvg /dev/sdc
  /proc/devices: No entry for device-mapper found
  Volume group "myvg" successfully extended
# vgextend myvg /dev/sdd
  /proc/devices: No entry for device-mapper found
  Volume group "myvg" successfully extended
----

I eliminated the warning my loading the dm-mirror module:

----
# modprobe dm-mirror
# vgreduce myvg /dev/sdd
  Removed "/dev/sdd" from volume group "myvg"
# vgextend myvg /dev/sdd
  Volume group "myvg" successfully extended
----

Let's see the PV and VG status before creating an LV:

----
# pvs
  PV         VG     Fmt  Attr PSize    PFree   
  /dev/sdb   myvg-b lvm2 a-   1020.00m 1020.00m
  /dev/sdc   myvg-c lvm2 a-   1020.00m 1020.00m
  /dev/sdd   myvg-d lvm2 a-   1020.00m 1020.00m
# vgs
  VG     #PV #LV #SN Attr   VSize    VFree   
  myvg-b   1   0   0 wz--n- 1020.00m 1020.00m
  myvg-c   1   0   0 wz--n- 1020.00m 1020.00m
  myvg-d   1   0   0 wz--n- 1020.00m 1020.00m
----

I created the lvm mirror (the only real difference to a normal LV is the -m 1
option):

----
# lvcreate -L 900M -n mymirror -m 1 myvg 
  Logical volume "mymirror" created
----

Now let's see the status again:

----
# pvs
  PV         VG   Fmt  Attr PSize    PFree   
  /dev/sdb   myvg lvm2 a-   1020.00m  120.00m
  /dev/sdc   myvg lvm2 a-   1020.00m  120.00m
  /dev/sdd   myvg lvm2 a-   1020.00m 1016.00m
# vgs
  VG   #PV #LV #SN Attr   VSize VFree
  myvg   3   1   0 wz--n- 2.99g 1.23g
# lvs
  LV       VG   Attr   LSize   Origin Snap%  Move Log           Copy%  Convert
  mymirror myvg mwi-a- 900.00m                    mymirror_mlog 100.00        
----

- LVS can even show which part of the mirror (one and the other side + log
  device) is located on which device:

----
# lvs -a -o +devices
  LV                  VG   Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  mymirror            myvg mwi-a- 900.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg iwi-ao 900.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg iwi-ao 900.00m                                                 /dev/sdc(0)                              
  [mymirror_mlog]     myvg lwi-ao   4.00m                                                 /dev/sdd(0)     
----

The device nodes are created as well:

----
# ls /dev/mapper
control  myvg-mymirror  myvg-mymirror_mimage_0  myvg-mymirror_mimage_1  myvg-mymirror_mlog
----

Finally I did the usual format/mount/check-free-space:

----
# mkfs.ext4 /dev/mapper/myvg-mymirror
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
57600 inodes, 230400 blocks
11520 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=239075328
8 block groups
32768 blocks per group, 32768 fragments per group
7200 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376

Writing inode tables: done                            
Creating journal (4096 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 23 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
# mkdir /mnt/mirror
# mount /dev/mapper/myvg-mymirror /mnt/mirror
# df -h
Filesystem            Size  Used Avail Use% Mounted on
/dev/sda1             7.9G  843M  6.7G  12% /
/dev/mapper/myvg-mymirror
                      886M   18M  824M   3% /mnt/mirror
----

Questions / TODOs:

- The log device is not redundant, is that expected?

Looks like that wasn't supported for a long time, the changelog says:

-----
Version 2.02.63 - 14th April 2010
  (...)
  Add ability to create mirrored logs for mirror LVs.
  (...)
----

- Gabor said that the current read strategy is an RR-based algorithm, I need to
  find out how to verify that.

- Is there anything fundamentally wrong in the steps I used for creating a dm-mirror?

- What would be the goals for the end of the semester? A simple goal I can
  think of is to first verify that currently one can't specify which PV is the
  preferred one when reading from dm-mirrors and if that's true, implement a way
  to be able to do so.

== 2nd week

Bookmarks from last week:

- http://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/5/html-single/Cluster_Logical_Volume_Manager/index.html#mirrored_volumes
- http://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/5/html-single/Cluster_Logical_Volume_Manager/index.html#LV_create

=== Part1: Installing RHEL, building dm-mirror

First I installed a RHEL Server 5.5 in VMware. (Nothing special, I disabled the
graphical part and enabled all development-related packages.) After
installation, my goal was to build the dm-mirror kernel module, so that I can
modify it. I did the followings:

----
$ cd ~
$ mkdir -p rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
$ echo '%_topdir %(echo $HOME)/rpmbuild' > .rpmmacros
$ curl -I ftp://ftp.redhat.com/redhat/linux/enterprise/5Server/en/os/SRPMS/kernel-2.6.18-194.11.4.el5.src.rpm
Last-Modified: Mon, 20 Sep 2010 09:21:47 GMT
(...)
$ wget ftp://ftp.redhat.com/redhat/linux/enterprise/5Server/en/os/SRPMS/kernel-2.6.18-194.11.4.el5.src.rpm
$ rpm -Uvh kernel-2.6.18-194.11.4.el5.src.rpm 2>&1 | grep -v mockb
----

To unpack and prepare (patch) the sources:

----
$ cd ~/rpmbuild/SPECS
$ rpmbuild -bp --target=`uname -m` kernel-2.6.spec 2> prep-err.log | tee prep-out.log
----

To build the dm-mirror module (the symvers part is necessary otherwise the
kernel will become tainted when the module is loaded):

----
$ cd ~/rpmbuild/BUILD/kernel-2.6.18/linux-2.6.18.i686
$ perl -p -i -e "s/^EXTRAVERSION.*/EXTRAVERSION = -194.el5/" Makefile

$ cp /boot/symvers-2.6.18-194.el5.gz .
$ gunzip symvers-2.6.18-194.el5.gz
$ mv symvers-2.6.18-194.el5 Module.symvers

$ make prepare
$ make modules_prepare
$ make M=drivers/md
# cp drivers/md/*.ko /lib/modules/2.6.18-194.el5/extra
# depmod -a
----

Only the last 3 commands has to be executed after each source code
modification.

Reloading the module can't be done without stopping the lvm mirror first:

----
# lvchange -a n myvg/mymirror
# rmmod dm-mirror
# modprobe dm-mirror
# lvchange -a y myvg/mymirror
----

I tried adding a sample modification:

- installed Git from EPEL
- added sources files under drivers/md to git
- added a debug printf to the init function of the dm_mirror module:

----
diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c
index 23c1d65..70cb224 100644
--- a/drivers/md/dm-raid1.c
+++ b/drivers/md/dm-raid1.c
@@ -1936,6 +1936,8 @@ static int __init dm_mirror_init(void)
 {
        int r;
 
+       printk("debug, dm-mirror init\n");
+
        _dm_raid1_read_record_cache = kmem_cache_create("bio_map_info",
                                sizeof(struct bio_map_info), 0, 0, NULL, NULL);
        if (!_dm_raid1_read_record_cache) {
----

And yes, after building, installing and reloading the module, the string
appeared in dmesg. :)

Used documentation:

- http://fedoraproject.org/wiki/EPEL/FAQ#howtouse
- http://wiki.centos.org/HowTos/BuildingKernelModules

=== Part 2: creating the LVM mirror

This was not necessary, the LVM mirror I created last week was recognized
automatically. (The mirror uses sdb, sdc and sdd, the system is on sda, so I
just the contents of sda during the installation of RHEL.)

=== Part 3: more documentation, questions

So after setting up the new build environment, I looked at the documentation
links Ivan provided.

I read the following pages:

- http://sources.redhat.com/lvm2/wiki/FeatureRequests/dm/mirroring

My note: This list is a bit confusing, it's not exactly clear what's
implemented and what is not. "Ability to handle device failures" is, not, sure
about the rest.

- http://sources.redhat.com/lvm2/wiki/MirrorDesignV1

Most important infos:

- state: clean, dirty (written and not yet synced), not-in-sync (the mirror device failed)
- current algorithm: round-robin - change device after every 128 requests
- log: can be different for each LV: core and device implementations
- trade-offs:

  * core (fast write, slow startup) vs device (slow write, fast startup)
  * region size: big (small log, lot of data to recover) vs small (large log, small amount of data to recover)

- handling failures:

  * reads: just try an other device
  * write: raise an event, then the userspace 'dmeventd' can handle them

My note: so the read algorithm is hardwired, but the log one can be configured
for each LV, something similar could be done for read algorithm as well to make
it configurable. If I remember correctly, Gabor was referring to make this
configurable at a global level via sysctl. That has the benefit of not changing
the LVM metadata, I guess.

Reading the code a bit, it turns out that a set of mirrors is stored in the
'mirror_set' struct and that has an array of 'mirrors' and a 'default_mirror'
pointer. So the code is already aware that from the N devices there is a
default one, just it's not possible to always read from there.

- http://sources.redhat.com/lvm2/wiki/MirrorDesignV2-discussion

This one is a bit confusing as well, as far as I see for example the "Ability
to have at least two log devices to avoid single point of log device failure.
The log devices can be used in replicated mode or hot/spare standby mode."
problem is already solved. (See 1st week, in LVM2 version 2.02.63.)

Other than that, I think the features mentioned here would be nice, just need
to check what is implemented and what is not.

=== Summary

This week I spent time on creating the development environment and
understanding current issues of dm-mirror. If that's OK with Ivan, that next
week (as a first task) I would try to add support of changing the read method
globally (via sysctl) so the user could choose between the current 'RR' method
and a new 'always read from the default mirror' one. Once this is completed, a
second step could be to turns this global setting a to per-LV setting, like one
can use '--corelog' when creating mirrored LV's to use an in-memory log device
instead of a physical one. Does this sound like a good direction?

Other question: in case I start the actual coding, how should I track / share
my changes? For now I just created a local git repo, but:

- Is there a git repo for the RHEL kernel I can clone? Or is it ok that I just
  create my own repo and once a feature is ready, we can squash all commits
  from that repo to a single patch, like the other huge patches in the kernel
  SRPM? (And even if that's the case, I found the git repo of Fedora's kernel
  at git://pkgs.fedoraproject.org/kernel, but I did not found somethething
  similar for RHEL - is it the best if I just stick to the kernel SRPM I
  downloaded today?)
- Where should I share my code? Is it OK if I push it to a public hosting site
  like gitorious.org or do you have a preference?

== 3rd week

=== Clarifications

----
> In Part 1:
> 
> you did a curl and a wget. Why were both of them necesary?
----

I used curl only for documentation purposes to show the date of the SRPM.

----
> In Part 3:
> 
> Where can you see this problem is solved? How do you make the log device to be used in replicated mode?
----

I haven't tried it myself, I just had a look at a recent lvm2 release (LVM2.2.02.73.tgz), in particual its WHATS_NEW file. In the 'Version 2.02.63' section, there is a line:

----
Add ability to create mirrored logs for mirror LVs.
----

I guess that means it's finally possible to avoid the single point of failure
regarding the log device. Or did I misunderstand something?

----
> Yes it does. There is one thing I'm missing here though: how do you choose the default mirror?
----

From the code, it seems that the 'default_mirror' pointer of rht 'mirror_set'
structure just always points to the first item in the set. So by defaul it
would be the first, then the user could change it if it's needed. (See below.)

----
> I think the sysctl global read method changing is a good first step.
> Once you are ready with that, it would be good to try it and prove it works as expected.
> As the second step, I would like to invite you to see about how to choose the default mirror.
> Then, the third step can be a per-mapping setting for the read method.
> (I refer to it as per-mapping instead of per-LV to stress it works in the device mapper to achieve the mirroring.)
> I would make this initially also a runtime setting, so as to avoid the need for changing the LVM metadata headers.
> 
> Is this ok with you?
----

Yes, that sounds fine.

----
> I need to think about this one. Once you have some working code, we would of course like to see it.
----

OK, I'll then keep the repo private for now, then you can decide where should I publish it.

=== Goals

Summary of the above:

- sysctl global setting + proove that it works
- see about how to choose the default mirror
- per-mapping setting for the read method (first just runtime to avoid metadata change)

=== Adding the sysctl global setting

A simple idea is to allow having the RR IO number (which is 128 by default and
has to be > 1 at the moment) as 0, which would mean reading only from the
default mirror. This code seems to be in drivers/md/dm-raid1.c. The
mirror_message() function can set this default 128 value when it receives a
message. After some searching, the userspace command to send messages to the
target is like this:

----
# dmsetup message myvg-mymirror 0 io_balance round_robin ios 128
----

Right now the "io_balance round_robin ios" part is fixed, and then the 4th
argument is the new value. But this can be extended to set different
properties, so I think it's a good idea to use this method (given that it's
already there + it's already device-specific) instead of sysctl.

The 'mirror_set' struct has two values for the io numbers: the 'rr_ios_set' is
the adjustable default, the 'rr_ios' is the current value (which is constantly
decremented after each read). The RR algorithm is done implemented in the
choose_mirror() function: the 'read_mirror' pointer is constantly decremented
and in case it would become invalid, it's moved to the end of the array again.

So what I did is:

- allow setting rr_ios_set value to 0
- in case rr_ios_set is 0, the ignore rr_ios and just return default_mirror in
  choose_mirror() (default_mirror is actually the first element of the mirror
  array at the moment, so there isn't any intelligent algorithm there to find out
  what would be a good default)
- added debug printk() to see which mirror is used

To build, install, and reload the kernel module, I defined:

----
$ alias build="make M=drivers/md"
$ alias install="sudo cp drivers/md/*.ko /lib/modules/2.6.18-194.el5/extra && sudo depmod -a"
$ alias reload="sudo sh -c '/usr/sbin/lvchange -a n myvg/mymirror; /sbin/rmmod dm-mirror; /sbin/modprobe dm-mirror; /usr/sbin/lvchange -a y myvg/mymirror'"
----

Then I just mounted /dev/mapper/myvg-mymirror to /mnt/mirror, that performs a
few reads already, just enough for quick testing.

dmesg output with rr_ios_set = 4:

----
device-mapper: raid1: Setting round robin read ios for "253:5" to 4
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
----

dmesg output with rr_ios_set = 0:

----
device-mapper: raid1: Setting round robin read ios for "253:5" to 0
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
----

(The first patch implements this.)

=== Choosing the default mirror

Now that I think about it - I think that's something that probably the user
wants to decide. Our use case was that one disk is local and the other is
remote, so a trivial solution is to add some interface where the user can set
what's the preferred one.

So for example, let's say sdb is local and sdc is remote. We get the LV name from lvs:

----
# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38G                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00M                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-ao 900.00M                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       iwi-ao 900.00M                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       iwi-ao 900.00M                                                 /dev/sdc(0)                              
  [mymirror_mlog]     myvg       lwi-ao   4.00M                                                 /dev/sdd(0)   
----

Then we can use dmsetup to get the numbers of mymirror_mimage_0:

----
# dmsetup ls
myvg-mymirror   (253, 5)
myvg-mymirror_mlog      (253, 2)
VolGroup00-LogVol01     (253, 1)
myvg-mymirror_mimage_1  (253, 4)
VolGroup00-LogVol00     (253, 0)
myvg-mymirror_mimage_0  (253, 3)
----

Finally send a message to set it as default:

----
# dmsetup message myvg-mymirror 0 io_balance default 253:3
----

dmesg output when the default device is 253:3:

----
device-mapper: raid1: Setting round robin read ios for "253:5" to 0
device-mapper: raid1: Setting default device for "253:5" to "253:3"
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
debug, choose_mirror(), choosed mirror is '253:3'
----

dmesg output when the default device is 253:4:

----
device-mapper: raid1: Setting default device for "253:5" to "253:4"
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
debug, choose_mirror(), choosed mirror is '253:4'
----

(The second patch implements this.)

=== Per-mapping setting for the read method

The idea is to use dmesetup messages instead of sysctl and in this case the
setting is already per-mapping.

=== Plans

Next week it would be nice to do some measurements, though right now I have no
idea how could we emulate a slow and a fast disk to show that in some cases
avoiding RR can cause a speedup.

Also, is it enough do be able to choose default mirror like this, or maybe we
could introduce some algorithm here as well?

So I'm open to ideas on what to do next.

== 4th week

Today's goal is to measure the speed of read in case of original and the
modified code. The idea is to use iSCSI to have one leg of the mirror on an
other machine, then limit the network speed.

=== Setting up the iSCSI target

In iSCSI terms, the target is the server. I installed a second RHEL in a
virtual machine for this purpose. The machine has two disks: one for the system
(sda, 8GB) and one to be exported by iSCSI (sdb, 1GB).

I did a minimal install, then installed the `scsi-target-utils` package. It had
some non-trivial dependencies, so I first had to configure yum for the install
media:

----
[root@iscsitarget repos.d]# cat /etc/yum/repos.d/Server.repo 
[ISOServer]
baseurl=file:///media/cdrom/Server
enabled=1
[root@iscsitarget repos.d]# ls /etc/yum/repos.d
Cluster.repo  ClusterStorage.repo  Server.repo
----

Then `yum install scsi-target-utils --nogpg` did the installation.

To configure the iSCSI target, first I experimented with runtime configuration.
After reading the manual pages, the following works here:

----
/etc/init.d/tgtd start
tgtadm --lld iscsi --op new --mode target --tid 1 -T iqn.2008-03.local.virtual2:storage
tgtadm --lld iscsi --op new --mode logicalunit --tid 1 --lun 1 -b /dev/sdb
tgtadm --lld iscsi --op bind --mode target --tid 1 -I ALL
----

The first command creates the storage with id=1, the second attaches sdb to
it, and the third just grants access to any initiator.

The status can be seen using:

----
tgtadm --lld iscsi --op show --mode target
----

The problem is that this configuration is not kept after restart. The solution
is to use the /etc/tgt/targets.conf configuration file:

----
# egrep -v '#|^$' /etc/tgt/targets.conf 
default-driver iscsi
<target iqn.2008-03.local.virtual2:storage>
    backing-store /dev/sdb
</target>
----

The comments in the configuration file mentions that the default is to allow
any initiators, so no need to explicitly state that there.

=== Setting up the iSCSI client

I installed the `iscsi-initiator-utils` package and started the client daemon:

----
/etc/init.d/iscsi start
----

Then discovered the targets on the other machine:

----
# iscsiadm --mode discovery --type sendtargets --portal iscsitarget
192.168.152.130:3260,1 iqn.2008-03.local.virtual2:storage
----

Finally restarted the iscsi service to create device nodes for the discovered
targets:

----
/etc/init.d/iscsi restart
----

I used fdisk to list the disks:

----
# fdisk -l |grep ^Disk
Disk /dev/sda: 8589 MB, 8589934592 bytes
Disk /dev/sdb: 1073 MB, 1073741824 bytes
Disk /dev/sdc: 1073 MB, 1073741824 bytes
Disk /dev/sdd: 1073 MB, 1073741824 bytes
Disk /dev/sde: 1073 MB, 1073741824 bytes
----

sde is the new device, created by the iscsi initiator.

=== Simulating slow network

But first I had to configure tc(8). Sadly the syntax changed over time, so for
example the old howto from TLDP does not help.
http://www.cyberciti.biz/faq/linux-traffic-shaping-using-tc-to-control-http-traffic/[This
one] looks like a fresh one.

To add network latency, I have:

----
tc qdisc add dev eth0 root netem delay 200ms
----

To reset the rules:

----
tc qdisc del dev eth0 root
----

Then I created two 2MB-sized test files (one local, one remote):

----
# dd if=/dev/zero of=/mnt/test/test bs=1M count=2
2+0 records in
2+0 records out
2097152 bytes (2.1 MB) copied, 0.0177618 seconds, 118 MB/s
# dd if=/dev/zero of=/mnt/iscsi/test bs=1M count=2
2+0 records in
2+0 records out
2097152 bytes (2.1 MB) copied, 0.023956 seconds, 87.5 MB/s
----

It took some time till I could choose a proper file size: small files are read
instantly, large files take forever. This file size looks like a sane decision
in the current environment:

----
# echo 3 > /proc/sys/vm/drop_caches; time cat /mnt/test/test >/dev/null

real    0m0.030s
user    0m0.003s
sys     0m0.014s
# echo 3 > /proc/sys/vm/drop_caches; time cat /mnt/iscsi/test >/dev/null

real    0m17.642s
user    0m0.000s
sys     0m0.021s
----

=== Measuring the mirror read speed

First I rebuilt the mirror: I now used sde (iscsi) instead of sdc for one leg
of the mirror:

----
# pvcreate /dev/sde1
# umount /mnt/mirror
# lvchange -a n myvg/mymirror
# lvremove /dev/mapper/myvg-mymirror
# vgremove myvg
# vgcreate myvg /dev/sdb
# vgextend myvg /dev/sde1
# vgextend myvg /dev/sdd
# lvcreate -L 900M -n mymirror -m 1 myvg
----

I used sde1 instead of sde, as - for some reason - lvcreate didn't like the
idea of using the full iscsi block device.

Later I also changed sdd to sdd1, as I had to change it size from 1G to 500M to
force using sdd for log device. So the result:

----
# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38G                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00M                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-a- 900.00M                    mymirror_mlog   1.33         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       Iwi-ao 900.00M                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       Iwi-ao 900.00M                                                 /dev/sde1(0)                             
  [mymirror_mlog]     myvg       lwi-ao   4.00M                                                 /dev/sdd1(0)     
----

I created the following test script to read the above test file from the
mirror:

----
#!/bin/bash

echo 3 > /proc/sys/vm/drop_caches
mount /dev/mapper/myvg-mymirror /mnt/mirror
time cat /mnt/mirror/test >/dev/null
umount /mnt/mirror
----

The default behaviour (RR with n=128) results in quite different read times,
depending on when the switch between the two PV occurs (traffic shaping enabled):

----
# sh test.sh

real    0m9.385s
user    0m0.000s
sys     0m0.046s
# sh test.sh

real    0m0.274s
user    0m0.003s
sys     0m0.068s
# sh test.sh

real    0m1.135s
user    0m0.001s
sys     0m0.051s
----

The output when forcing local reads:

----
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance round_robin ios 0
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance default 253:3
[root@projlab2 ~]# sh test.sh 

real    0m0.282s
user    0m0.002s
sys     0m0.063s
[root@projlab2 ~]# sh test.sh 

real    0m0.259s
user    0m0.002s
sys     0m0.063s
[root@projlab2 ~]# sh test.sh 

real    0m0.224s
user    0m0.000s
sys     0m0.062s
----

The output when forcing remote reads (traffic shaping disabled):

----
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance default 253:4
[root@projlab2 ~]# sh test.sh 

real    0m1.262s
user    0m0.002s
sys     0m0.045s
[root@projlab2 ~]# sh test.sh 

real    0m2.004s
user    0m0.001s
sys     0m0.054s
[root@projlab2 ~]# sh test.sh 

real    0m1.644s
user    0m0.002s
sys     0m0.049s
----

With traffic shaping enabled:

----
[root@projlab2 ~]# sh test.sh 

real    0m22.826s
user    0m0.001s
sys     0m0.047s
[root@projlab2 ~]# sh test.sh 

real    0m20.225s
user    0m0.000s
sys     0m0.040s
[root@projlab2 ~]# sh test.sh 

real    0m13.339s
user    0m0.001s
sys     0m0.042s
----

I think the numbers above state quite nicely what we expected.

=== Questions

What should be the next item to continue with?

A few problems I can think of:

- Try out what happens when one or the other disks fail. (Does it really just properly rebuild the mirror from the log?)
- Try out that mirrored log feature we talked about and see how it works
- Handle the case when the difference is not that dramatic (like the
  local/remote case), when the ratio is like 1:2, then maybe it still makes
  sense to do some weighted round-robin?
- Save the settings to LVM metadata what we have only at runtime at the moment
- Some magic to set the default mirror to the fastest one automatically?

What's your preference?

== 5th week

=== Trying out what happens when one or the other disk fails

I changed back previous week's setup: so the mirror now consists again from `sdb`
and `sdc` for the data and `sdd` for the log. Given that the other machine is off, there would be a long hang (till the connection times out) when the machine tries to connect to the iscsi server, so I used:

----
[root@projlab2 ~]# chkconfig --del iscsi
----

for now. I created some file on the mirror:

----
[root@projlab2 mnt]# mount /dev/mapper/myvg-mymirror /mnt/mirror
[root@projlab2 mnt]# cd /mnt/mirror/
[root@projlab2 mirror]# echo some data > myfile
----

Then I shut down the machine, removed `sdc` (`projlab2-1-000002.vmdk`) from
the config and started it again.

I got the following during boot:

----
Setting up Logical Volume Management:   Couldn't find device with uuid 'ShYeaa-Hsu8-VquL-6Qrt-IPUa-Evzo-A0Oaus'.
  Refusing activation of partial LV mymirror. Use --partial to override.
  0 logical volume(s) in volume group "myvg" now active
  2 logical volume(s) in volume group "VolGroup00" now active
                                                           [FAILED]
----

So it stays on the safe side and the mirror device isn't even created. I tried activating the LV in partial mode, then:

----
[root@projlab2 ~]# lvchange --partial -a y myvg/mymirror
  Partial mode. Incomplete volume groups will be activated read-only.
  Couldn't find device with uuid 'ShYeaa-Hsu8-VquL-6Qrt-IPUa-Evzo-A0Oaus'.
----

That 'read-only' does not mean read-only filesystem though:

----
[root@projlab2 ~]# mount /dev/mapper/myvg-mymirror /mnt/mirror/
[root@projlab2 ~]# cd /mnt/mirror/
[root@projlab2 mirror]# ls
lost+found  myfile
[root@projlab2 mirror]# cat myfile 
some data
[root@projlab2 mirror]# echo more data >> myfile 
----

Let's see what happens when I put back `sdc`:

----
Setting up Logical Volume Management:   Write locks are prohibited with --ignorelockingfailure.
  Recovery of volume group "myvg" failed.
  Internal error: Attempt to unlock unlocked VG myvg.
  2 logical volume(s) in volume group "VolGroup00" now active
                                                           [FAILED]
----

Whatever that means, let's see if the LV is really not available:

----
[root@projlab2 ~]# lvs
  LV       VG         Attr   LSize   Origin Snap%  Move Log Copy%  Convert
  LogVol00 VolGroup00 -wi-ao   7.38G                                      
  LogVol01 VolGroup00 -wi-ao 512.00M                                      
  mymirror myvg       -wi--- 900.00M            
-----

Right, we have to manually make it available:

----
[root@projlab2 ~]# lvchange -a y myvg/mymirror
[root@projlab2 ~]# mount /dev/mapper/myvg-mymirror /mnt/mirror/
[root@projlab2 ~]# lvs -a -o +devices
  LV       VG         Attr   LSize   Origin Snap%  Move Log Copy%  Convert Devices       
  LogVol00 VolGroup00 -wi-ao   7.38G                                       /dev/sda2(0)  
  LogVol01 VolGroup00 -wi-ao 512.00M                                       /dev/sda2(236)
  mymirror myvg       -wi-ao 900.00M                                       /dev/sdb(0)   
----

So after a manual activation it's available and online, but it's no longer a
mirror. It's not trivial how to turn it to a mirror again, so I searched.

First, I
https://www.redhat.com/archives/linux-lvm/2009-September/msg00118.html[found]
that I can simulate the device failure without a restart:

----
[root@projlab2 ~]# echo 1 > /sys/bus/scsi/devices/0\:0\:2\:0/delete 
[root@projlab2 ~]# ls /dev/sdc
ls: /dev/sdc: No such file or directory
[root@projlab2 ~]# echo "- - -" > /sys/class/scsi_host/host0/scan 
[root@projlab2 ~]# ls /dev/sdc
/dev/sdc
----

From that thread it's also clear that the log device is only used to avoid a
complete resync on every reboot, it's not yet used to handle device failures.
`dmeventd` just removes the failed device *and* the mirror log from the LV so
it becomes just a regular linear one. This is an important fact, that means in
case the log fails, it will just take a lot of time to recover, but it won't
cause a data loss!

Second,
http://docs.redhat.com/docs/en-US/Red_Hat_Enterprise_Linux/5/html/Cluster_Logical_Volume_Manager/mirrorrecover.html[here]
is the official relevant documentation. From that, I needed:

----
[root@projlab2 ~]# pvcreate /dev/sdc
  Physical volume "/dev/sdc" successfully created
[root@projlab2 ~]# pvcreate /dev/sdd1
  Physical volume "/dev/sdd1" successfully created
[root@projlab2 ~]# vgextend myvg /dev/sdc /dev/sdd1
  Volume group "myvg" successfully extended
[root@projlab2 ~]# lvconvert -m 1 /dev/myvg/mymirror /dev/sdb /dev/sdc /dev/sdd1
  myvg/mymirror: Converted: 100.0%
[root@projlab2 ~]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38G                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00M                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-ao 900.00M                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       iwi-ao 900.00M                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       iwi-ao 900.00M                                                 /dev/sdc(0)                              
  [mymirror_mlog]     myvg       lwi-ao   4.00M                                                 /dev/sdd1(0)   
----

Now let's try killing `sdb`, without a restart - that will allow me to see
dmeventd messages:

----
[root@projlab2 log]# echo 1 > /sys/bus/scsi/devices/0\:0\:1\:0/delete
[root@projlab2 mirror]# echo "3rd line - after sdd fail" >> /mnt/mirror/myfile
[root@projlab2 log]# tail -2 /var/log/messages 
Oct  6 15:25:32 projlab2 lvm[4108]: Repair of mirrored LV myvg/mymirror finished successfully.
Oct  6 15:25:33 projlab2 lvm[4108]: No longer monitoring mirror device myvg-mymirror for events 
----

The "recover" means that it got converted to a linear LV. After this, the above
pvcreate, vgextend, lvconvert combo recovered the mirror:

----
[root@projlab2 log]# tail -2 /var/log/messages 
Oct  6 15:28:27 projlab2 lvm[4108]: Monitoring mirror device myvg-mymirror for events
Oct  6 15:28:55 projlab2 lvm[4108]: myvg-mymirror is now in-sync 
----

Other than that, it works like a charm, the file-system was continuously mounted
in read-write while first `sdc` then `sdd` failed. ;)

=== Trying out the mirrored log feature

As I mentioned earlier, this is announced as a new feature in 2.02.63. I wanted
to see the commit that added this to the changelog to see if it added some
(more than that single line) documentation on it or testcases or anything. The
LVM2 homepage states that they are still using CVS. This is bad, as in CVS it's
hard to see a single commit modified what other files. Then I found
http://git.et.redhat.com/?p=lvm2.git which hasn't updated in the last year, so
it's not useful for this situation (the commit in question is somewhere this
year April). So I started importing the CVS repo to git myself, and *then* I
found http://sourceware.org/git/?p=lvm2.git which is updated properly. ;)

From that repo, commit 3318c413 is the interesting one. As the commit message
says, the mirrored log is a new type of log (next to `disk` and `core`), called
`mirrored`.

Given that RHEL5 comes with lvm2-2.02.56 by default, first I wanted to update
it to at least 2.02.63. Searching in the changelog later versions add important
bugfixes to the mirrored log support, so newer versions are interesting as
well.

I see the following possibilities here:

- backport that single patch to the RHEL5 version. Pro: I don't have to alter the version of the lvm2 package which is already provided. Con: it may be hard to do so, I will miss later bugfixes if I just cherry-pick that single patch.
- backport a whole new lvm2 version. Pro: that will bring in all the new bugfixes, touching code that I'm unfamiliar with is not necessary. Con: the newer package may or may not work (especially that device-mapper has been merged to LVM2 in the meantime, so there are major changes).
- don't test it on RHEL5, but try this feature on Fedora. Pro: no manual building of SRPM Con: have to install a new virtual machine

For now, I choose the second: the goal is to backport
lvm2-2.02.73-1.fc14.src.rpm from Fedora 14. (As far as I know there are no
public RHEL development SRPM's out there.)

Building and installing it went fine, I just had to disable udev and cluster
support in the spec file and add a BuildRoot line.

To test it, I needed one more disk in the virtual machine, so that sda runs the
system, sdb/sdc the data and sdd/sde contains the log. (Of course it would be
possible to just use multiple partitions / disk, sure.)

After that, I could create the LV with mirrored log:

----
[root@projlab2 ~]# pvcreate /dev/sde1
  Physical volume "/dev/sde1" successfully created
[root@projlab2 ~]# vgextend myvg /dev/sde1
  Volume group "myvg" successfully extended
[root@projlab2 ~]# lvcreate -L 900M -n mymirror -m 1 myvg --mirrorlog mirrored
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                       VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                            
  LogVol00                 VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                                       
  LogVol01                 VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                                     
  mymirror                 myvg       mwi-a- 900.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_0]      myvg       iwi-ao 900.00m                                                 /dev/sdc(0)                                        
  [mymirror_mimage_1]      myvg       iwi-ao 900.00m                                                 /dev/sdb(0)                                        
  [mymirror_mlog]          myvg       mwi-ao   4.00m                                  100.00         mymirror_mlog_mimage_0(0),mymirror_mlog_mimage_1(0)
  [mymirror_mlog_mimage_0] myvg       iwi-ao   4.00m                                                 /dev/sde1(0)                                       
  [mymirror_mlog_mimage_1] myvg       iwi-ao   4.00m                                                 /dev/sdd1(0)
----

=== Checking what does the mirror log contain

From a quick Google, a
http://www.linuxquestions.org/questions/linux-software-2/log-file-size-when-mirroring-with-lvm2-788578/[forum
post] mentions the typical size of a log volume and from that it's clear it
just tracks which regions are in sync and which are not, it does not contain
real data.

=== Summary

- handling of failed disks in dm-mirror works properly, though the "Repair of
  mirrored LV ... finished successfully." message is rather confusing (on its
  own) on a device *failure*
- having mirrored log volumes is possible, though that feature is not yet in
  the last RHEL release nor really necessary as loosing the mirror log does not
  cause data loss
- the log device is just used for restarts, not for recovery (this could be
  improved)

=== Questions

- What to continue with? One idea is to see how can I manage to persist the
  settings which can be configured (currently only runtime) using dmsetup
  message.
- If you think it worths submitting, how should I contribute my changes to the
  RHEL/upstream kernel?

== 6th week

=== Plan: how to test writes

The plan is to do the measurements Ivan recommended in his mail:

----
to your question what to do next, I would like you to make some experiments with the write behavior
of the mirror. What happens when the network is slow? What happens when the network is sometimes
broken and then it comes back again? In the first instance, I would like you to do these experiments
with RHEL5, with a normal mirror with 1 log. If you think that in this situation a mirrorred log would
help, then please make some experiments with RHEL6 Beta, which is publicly available for download, because
+it already has the mirrorred log feature (as lvm has a much higher version number there).

As a summary of the above, here is a short of the measurements I have in mind:
 - tests on RHEL5
   - write behavior with two legs and log accessible with the same speed
   - write behavior with on leg and log accessible with reduced speed, with various settings, like 1:2, 1:5, 1:10, 1:50, 1:100
   - write behavior with a shaky connection to one leg and log
+   - the same tests as above, but the log is accessible on the fast leg all the time
 - tests on RHEL6beta
   - the same tests as above

Then, we can decide whether we need to backport this mirrorred log feature to RHEL5.

What do you think?
----

So to summarize the questions, the use-cases are:

- network is fast vs slow
- network goes away and then recovers
- different configuration: 1 log vs mirrored log

I think the measurements mentioned above are fine, since they cover the above
scenarios.

For network delays we can use something like 5ms, 10ms, 50ms, 100ms, 200ms.

=== Simulating reduced speed

So far I just used `tc` to insert a network delay, now I had to read
documentation to find out how to simulate slow bandwidth rate, which is a
different problem. I tried
http://lartc.org/howto/lartc.cookbook.ultimate-tc.html[this howto] - and used the HTB script from there. Saved it as limit.sh and added support for start/stop parameters to make my life easy.

Then I first tested write to iscsitarget with traffic shaping enabled (limited to 10.000 kilobits), then disabled:

----
[root@projlab2 ~]# time scp test-2mb.img iscsitarget:
test-2mb.img                                                                                              100% 2048KB   2.0MB/s   00:00    

real    0m22.951s
user    0m0.523s
sys     0m0.535s
[root@projlab2 ~]# time scp test-2mb.img iscsitarget:
test-2mb.img                                                                                              100% 2048KB   2.0MB/s   00:01    

real    0m2.650s
user    0m0.583s
sys     0m0.586s
----

As expected, the second time is about tenth of the first one. Just to be sure,
I also tried "limiting" the traffic to 100MBit (enabled, then disabled):

----
[root@projlab2 ~]# time scp test-2mb.img iscsitarget:
test-2mb.img                                                                                              100% 2048KB   2.0MB/s   00:01    

real    0m1.705s
user    0m0.438s
sys     0m0.481s
[root@projlab2 ~]# time scp test-2mb.img iscsitarget:
test-2mb.img                                                                                              100% 2048KB   2.0MB/s   00:00    

real    0m1.767s
user    0m0.419s
sys     0m0.358s
----

As you can see, there is no real difference. Now we can easily simulate half
network speed and other ratios.

=== Simulating shaky network connection

This has two parts:

- network delays can happen
- packets may be lost

For now, I just simulated the network delays - packet loss probably results in
a delay at higher level as well, since iSCSI just re-tries sending the requests
when necessary.

=== The measures

My test script is the following:

----
[root@projlab2 ~]# cat test-write.sh 
#!/bin/bash

mount /dev/mapper/myvg-mymirror /mnt/mirror
sync
time sh -c 'dd if=/dev/zero of=/mnt/mirror/test-2mb.img bs=1M count=2; sync' 2>/dev/null
umount /mnt/mirror
----

So it writes 2MB to the mirror and it avoids getting false results due to write
caching.

==== single log, local log, local disks

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdc /dev/sdd
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 900M -n mymirror -m 1 myvg
  Logical volume "mymirror" created
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

Test results:

----
[root@projlab2 ~]# ./test-write.sh

real    0m0.591s
user    0m0.003s
sys     0m0.038s
[root@projlab2 ~]# ./test-write.sh

real    0m0.603s
user    0m0.001s
sys     0m0.039s
[root@projlab2 ~]# ./test-write.sh

real    0m0.588s
user    0m0.005s
sys     0m0.034s
----

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== single log, remote log, local and remote disk: 1:2, 1:5, 1:10, 1:50, 1:100 network ratio limit

Setup:

- created sdb1 and sdb1 on iscsitarget and started the daemon:

----
[root@iscsitarget ~]# /etc/init.d/tgtd start
Starting SCSI target daemon:                               [  OK  ]
----

- configured the client:

----
[root@projlab2 ~]# /etc/init.d/iscsi start
iscsid (pid  2237) is running...
Setting up iSCSI targets: Logging in to [iface: default, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]
Login to [iface: default, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]: successful
                                                           [  OK  ]
[root@projlab2 ~]# fdisk -l|tail -n 2
/dev/sdf1               1          65      522081   83  Linux
/dev/sdf2              66         130      522112+  83  Linux
----

So the remote disk appeared as sdf.

- configured the mirror:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdf2
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 400M -n mymirror -m 1 myvg
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-a- 400.00m                    mymirror_mlog  11.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       Iwi-ao 400.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       Iwi-ao 400.00m                                                 /dev/sdf1(0)                             
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdf2(0) 
[root@projlab2 ~]# tail -n 1 /var/log/messages
Oct  6 20:50:36 projlab2 lvm[3487]: myvg-mymirror is now in-sync.
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

Test results:

----
[root@iscsitarget ~]# ./limit.sh start $((100000/2))
[root@projlab2 ~]# ./test-write.sh 

real    0m1.705s
user    0m0.002s
sys     0m0.055s
[root@projlab2 ~]# ./test-write.sh 

real    0m1.841s
user    0m0.002s
sys     0m0.055s
[root@projlab2 ~]# ./test-write.sh 

real    0m1.939s
user    0m0.001s
sys     0m0.055s
[root@iscsitarget ~]# ./limit.sh start $((100000/5))
[root@projlab2 ~]# ./test-write.sh 

real    0m21.716s
user    0m0.001s
sys     0m0.051s
[root@projlab2 ~]# ./test-write.sh 

real    0m23.399s
user    0m0.001s
sys     0m0.052s
[root@projlab2 ~]# ./test-write.sh 

real    0m23.503s
user    0m0.002s
sys     0m0.065s
[root@iscsitarget ~]# ./limit.sh start $((100000/10))
[root@projlab2 ~]# ./test-write.sh 

real    0m38.133s
user    0m0.004s
sys     0m0.055s
[root@projlab2 ~]# ./test-write.sh 

real    0m38.124s
user    0m0.002s
sys     0m0.056s
[root@projlab2 ~]# ./test-write.sh 

real    0m36.606s
user    0m0.005s
sys     0m0.052s
[root@iscsitarget ~]# ./limit.sh start $((100000/50))
[root@projlab2 ~]# ./test-write.sh 

real    0m47.035s
user    0m0.003s
sys     0m0.059s
[root@projlab2 ~]# ./test-write.sh 

real    0m48.205s
user    0m0.003s
sys     0m0.053s
[root@projlab2 ~]# ./test-write.sh 

real    0m47.688s
user    0m0.000s
sys     0m0.054s
[root@iscsitarget ~]# ./limit.sh start $((100000/100))
[root@projlab2 ~]# ./test-write.sh 

real    0m49.633s
user    0m0.001s
sys     0m0.057s
[root@projlab2 ~]# ./test-write.sh 

real    0m48.240s
user    0m0.001s
sys     0m0.054s
[root@projlab2 ~]# ./test-write.sh 

real    0m48.057s
user    0m0.001s
sys     0m0.048s
----

The results are quite linear, except that the result for 1:100 is almost the
same as 1:50, that's interesting.

Tear down:

----
[root@iscsitarget ~]# ./limit.sh stop
----

==== single log, remote log, local and remote disk: 5ms, 10ms, 50ms, 100ms, 200ms delay

I used the tc commands described on the 4th week to create a delay.sh which
just sets the network delay.

No setup, the mirror was already there.

Test results:

----
[root@iscsitarget ~]# ./delay.sh start 5
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m0.577s
user    0m0.002s
sys     0m0.052s

real    0m0.653s
user    0m0.002s
sys     0m0.062s

real    0m1.239s
user    0m0.002s
sys     0m0.065s
[root@iscsitarget ~]# ./delay.sh start 10
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m1.086s
user    0m0.000s
sys     0m0.056s

real    0m0.564s
user    0m0.002s
sys     0m0.055s

real    0m0.606s
user    0m0.001s
sys     0m0.054s
[root@iscsitarget ~]# ./delay.sh start 50
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m2.649s
user    0m0.003s
sys     0m0.053s

real    0m2.622s
user    0m0.000s
sys     0m0.058s

real    0m2.759s
user    0m0.002s
sys     0m0.064s
[root@iscsitarget ~]# ./delay.sh start 100
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m6.067s
user    0m0.002s
sys     0m0.053s

real    0m3.517s
user    0m0.001s
sys     0m0.057s

real    0m3.441s
user    0m0.001s
sys     0m0.056s
[root@iscsitarget ~]# ./delay.sh start 200
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m16.352s
user    0m0.002s
sys     0m0.065s

real    0m13.930s
user    0m0.002s
sys     0m0.060s

real    0m10.392s
user    0m0.001s
sys     0m0.053s
----

Tear down:

----
[root@iscsitarget ~]# ./delay.sh stop
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== single log, local log, local and remote disk: 1:2, 1:5, 1:10, 1:50, 1:100 network ratio limit

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdc
  /dev/hdc: open failed: Read-only file system
  /dev/hdc: open failed: Read-only file system
  /dev/hdc: open failed: Read-only file system
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 400M -n mymirror -m 1 myvg
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-a- 400.00m                    mymirror_mlog   7.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       Iwi-ao 400.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       Iwi-ao 400.00m                                                 /dev/sdf1(0)                             
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdc(0)    
[root@projlab2 ~]# tail -n 1 /var/log/messages
Oct  6 21:25:18 projlab2 lvm[3487]: myvg-mymirror is now in-sync.
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

Test results:

----
[root@iscsitarget ~]# ./limit.sh start $((100000/2))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m2.460s
user    0m0.002s
sys     0m0.056s

real    0m5.277s
user    0m0.002s
sys     0m0.057s

real    0m2.415s
user    0m0.007s
sys     0m0.060s
[root@iscsitarget ~]# ./limit.sh start $((100000/5))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m5.028s
user    0m0.001s
sys     0m0.056s

real    0m6.440s
user    0m0.003s
sys     0m0.064s

real    0m9.629s
user    0m0.005s
sys     0m0.072s
[root@iscsitarget ~]# ./limit.sh start $((100000/10))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m4.528s
user    0m0.000s
sys     0m0.052s

real    0m11.906s
user    0m0.003s
sys     0m0.050s

real    0m4.195s
user    0m0.001s
sys     0m0.051s
[root@iscsitarget ~]# ./limit.sh start $((100000/50))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m45.302s
user    0m0.002s
sys     0m0.052s

real    0m48.226s
user    0m0.001s
sys     0m0.048s

real    0m44.406s
user    0m0.001s
sys     0m0.054s
[root@iscsitarget ~]# ./limit.sh start $((100000/100))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m48.311s
user    0m0.004s
sys     0m0.053s

real    0m46.820s
user    0m0.000s
sys     0m0.053s

real    0m48.314s
user    0m0.001s
sys     0m0.051s
----

Same as before: somehow the 1:50 and 1:100 result is almost the same.

Tear down:

----
[root@iscsitarget ~]# ./limit.sh stop
----

==== single log, local log, local and remote disk: 5ms, 10ms, 50ms, 100ms, 200ms delay

No setup, the mirror is the same as with the previous test.

Test results:

----
[root@iscsitarget ~]# ./delay.sh start 5
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m3.736s
user    0m0.001s
sys     0m0.050s

real    0m3.489s
user    0m0.002s
sys     0m0.061s

real    0m3.166s
user    0m0.004s
sys     0m0.066s
[root@iscsitarget ~]# ./delay.sh start 10
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m3.267s
user    0m0.004s
sys     0m0.048s

real    0m3.872s
user    0m0.004s
sys     0m0.053s

real    0m2.846s
user    0m0.002s
sys     0m0.065s
[root@iscsitarget ~]# ./delay.sh start 50
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m2.844s
user    0m0.003s
sys     0m0.060s

real    0m3.929s
user    0m0.003s
sys     0m0.063s

real    0m2.306s
user    0m0.003s
sys     0m0.054s
[root@iscsitarget ~]# ./delay.sh start 100
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m5.306s
user    0m0.000s
sys     0m0.064s

real    0m4.578s
user    0m0.000s
sys     0m0.058s

real    0m4.402s
user    0m0.005s
sys     0m0.053s
[root@iscsitarget ~]# ./delay.sh start 200
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m7.114s
user    0m0.002s
sys     0m0.061s

real    0m5.978s
user    0m0.002s
sys     0m0.053s

real    0m8.920s
user    0m0.001s
sys     0m0.051s
----

Tear down:

----
[root@iscsitarget ~]# ./delay.sh stop
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== mirrored log, local disks

For now, I tested this on my RHEL5 machine where I already had the backported
lvm2 from last week. This has the benefit that other components of the system
is not changed. The downside is that this way the measurement is less official,
since then this is a custom system.

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdc /dev/sdd /dev/sde
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 400M -n mymirror -m 1 myvg --mirrorlog mirrored
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                       VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                            
  LogVol00                 VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                                       
  LogVol01                 VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                                     
  mymirror                 myvg       mwi-a- 400.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_0]      myvg       iwi-ao 400.00m                                                 /dev/sdb(0)                                        
  [mymirror_mimage_1]      myvg       iwi-ao 400.00m                                                 /dev/sdc(0)                                        
  [mymirror_mlog]          myvg       mwi-ao   4.00m                                  100.00         mymirror_mlog_mimage_0(0),mymirror_mlog_mimage_1(0)
  [mymirror_mlog_mimage_0] myvg       iwi-ao   4.00m                                                 /dev/sdd(0)                                        
  [mymirror_mlog_mimage_1] myvg       iwi-ao   4.00m                                                 /dev/sde(0)         
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror 
----

Test results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m3.183s
user    0m0.005s
sys     0m0.048s

real    0m3.181s
user    0m0.001s
sys     0m0.054s

real    0m3.195s
user    0m0.001s
sys     0m0.052s
----

Compared to the single log, this sounds like a huge overhead - just to have
faster start-up in case one of the log devices crash.

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== mirrored log, local and remote disk: 1:2, 1:5, 1:10, 1:50, 1:100 network ratio limit

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdc /dev/sdf2
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 400M -n mymirror -m 1 myvg --mirrorlog mirrored
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                       VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                            
  LogVol00                 VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                                       
  LogVol01                 VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                                     
  mymirror                 myvg       mwi-a- 400.00m                    mymirror_mlog   6.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_0]      myvg       Iwi-ao 400.00m                                                 /dev/sdb(0)                                        
  [mymirror_mimage_1]      myvg       Iwi-ao 400.00m                                                 /dev/sdf1(0)                                       
  [mymirror_mlog]          myvg       mwi-ao   4.00m                                  100.00         mymirror_mlog_mimage_0(0),mymirror_mlog_mimage_1(0)
  [mymirror_mlog_mimage_0] myvg       iwi-ao   4.00m                                                 /dev/sdc(0)                                        
  [mymirror_mlog_mimage_1] myvg       iwi-ao   4.00m                                                 /dev/sdf2(0)         
[root@projlab2 ~]# tail -n 1 /var/log/messages
Oct  6 22:08:58 projlab2 lvm[3487]: myvg-mymirror is now in-sync.
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

Test results:

----
[root@iscsitarget ~]# ./limit.sh start $((100000/2))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m1.756s
user    0m0.002s
sys     0m0.061s

real    0m2.026s
user    0m0.003s
sys     0m0.067s

real    0m2.316s
user    0m0.003s
sys     0m0.069s
[root@iscsitarget ~]# ./limit.sh start $((100000/5))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh

real    0m21.773s
user    0m0.002s
sys     0m0.081s

real    0m23.324s
user    0m0.003s
sys     0m0.060s

real    0m22.887s
user    0m0.002s
sys     0m0.063s
[root@iscsitarget ~]# ./limit.sh start $((100000/10))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m38.318s
user    0m0.005s
sys     0m0.050s

real    0m38.181s
user    0m0.002s
sys     0m0.050s

real    0m38.240s
user    0m0.002s
sys     0m0.053s
[root@iscsitarget ~]# ./limit.sh start $((100000/50))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m47.423s
user    0m0.004s
sys     0m0.063s

real    0m45.946s
user    0m0.002s
sys     0m0.057s

real    0m47.901s
user    0m0.001s
sys     0m0.053s
[root@iscsitarget ~]# ./limit.sh start $((100000/100))
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m50.239s
user    0m0.001s
sys     0m0.050s

real    0m48.765s
user    0m0.002s
sys     0m0.052s

real    0m48.075s
user    0m0.003s
sys     0m0.052s
----

Tear down:

----
[root@iscsitarget ~]# ./limit.sh stop
----

==== mirrored log, local and remote disk: 5ms, 10ms, 50ms, 100ms, 200ms delay

No setup, we just re-use the mirror from the previous test.

Test results:

----
[root@iscsitarget ~]# ./delay.sh start 5
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m1.380s
user    0m0.006s
sys     0m0.050s

real    0m0.824s
user    0m0.008s
sys     0m0.053s

real    0m0.636s
user    0m0.001s
sys     0m0.056s
[root@iscsitarget ~]# ./delay.sh start 10
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m1.300s
user    0m0.001s
sys     0m0.059s

real    0m0.741s
user    0m0.003s
sys     0m0.050s

real    0m0.776s
user    0m0.006s
sys     0m0.058s
[root@iscsitarget ~]# ./delay.sh start 50
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m3.430s
user    0m0.002s
sys     0m0.054s

real    0m3.009s
user    0m0.002s
sys     0m0.070s

real    0m3.228s
user    0m0.005s
sys     0m0.051s
[root@iscsitarget ~]# ./delay.sh start 100
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m7.673s
user    0m0.003s
sys     0m0.061s

real    0m4.269s
user    0m0.000s
sys     0m0.051s

real    0m3.583s
user    0m0.003s
sys     0m0.055s
[root@iscsitarget ~]# ./delay.sh start 200
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m14.233s
user    0m0.003s
sys     0m0.069s

real    0m11.855s
user    0m0.003s
sys     0m0.057s

real    0m11.066s
user    0m0.002s
sys     0m0.058s
----

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
[root@projlab2 ~]# /etc/init.d/iscsi stop
Logging out of session [sid: 1, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]
Logout of [sid: 1, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]: successful
Stopping iSCSI daemon: 
[root@projlab2 ~]# ls /dev/sdf
ls: /dev/sdf: No such file or directory
[root@iscsitarget ~]# ./delay.sh stop
----

=== Summary

- The measured numbers are not always the ones we expected, though generally they are OK, I think.
- One false effect is that 'sync' does not do empty the write cache on the 'iscsitarget' node.
- In general, I would say the mirrored log is a nice feature, as that way the
  two leg of the mirror can be really identical, but OTOH it seems to be a huge
  overhead with no major benefits.

What to work on next:

- More measures? Maybe a more automated setup would provide better numbers.
- Improve performance? For example it would be possible to let the dm-mirror kernel module handle do weighted RR, in case a simple RR is suboptimal, but just reading from a single disk isn't the best, either.
- Add support for storing the RR number or the default mirror device to the LVM metadata?

These are, of course, just ideas.

== 7th week

No new development or measures, I created a more formal interim report with
tables and charts from the measured data (attached).

== 8th week

=== Improving interim report

Worked on rounding the rough edges of the interim report:

- get rid of "just" and "like", which are not professional enough for a technical report
- explained mirror indexes and the concept of a default mirror
- the part explaining the introduction of rr_ios_set = 0 feature is now split
  to multiple simple sentences
- Conclusions / What to work on next: improved style
- added figure showing the architecture of the test environment
- explained why tc and htb simulates network latency and bandwidth limit
  properly
- explained how a 200ms delay can cause a 30ms -> 17s huge overhead
- replaced 'w/' and 'w/o' with proper descriptions
- added 'set up' and 'tear down' descriptions to the write tests

=== Measuring in real environment

The change to the environment is that now the iSCSI target is not a virtual
machine on the same physical host, but it's really a remote machine.

The following steps were needed:

- discover the target:

----
[root@projlab2 ~]# iscsiadm --mode discovery --type sendtargets --portal sy.ulx.hu:13260
----

- change the port and the ip in the config, as the values reported by the
  target are not suitable for me (since I'm outside the firewall):

----
[root@projlab2 ~]# vi /var/lib/iscsi/nodes/iqn.2010-10.hu.ulx\:san.remote/172.16.3.39\,3260\,1/default
----

and there I changed the address and port to:

----
node.conn[0].address = 81.183.209.160
node.conn[0].port = 13260
----

- then I got error messages:

----
[root@projlab2 ~]# grep trouble /var/log/messages|tail -n 1
Oct 30 19:59:05 projlab2 setroubleshoot: SELinux is preventing the iscsid (iscsid_t) from connecting to port 13260. For complete SELinux messages. run sealert -l ce2bcba8-efe3-4630-a670-9092e5c54054
----

Fow now, I just worked that around by:

----
[root@projlab2 mnt]# echo 0 > /selinux/enforce
----

Then logging in with `iscsiadm` went fine. At this point I had the following disks:

- sda: local system
- sdb, sdc, sdd, sde: 1G local disks
- sdf, sdg: 1G remote disks

I was just curious about the raw throughput first, so I created an sdf1 partition, formatted with ext3, mounted, then:

----
[root@projlab2 ~]# sync
[root@projlab2 ~]# time sh -c "dd if=/dev/zero of=/mnt/iscsi/test-2mb.img bs=1M count=2; sync" 2>/dev/null

real    0m11.648s
user    0m0.002s
sys     0m0.040s
----

So it's about 1.3MBit. Now let's see the measures! This will be a bit shorter
than the previous one as we have fixed network delay and bandwidth limitation,
but also more interesting as it's real.

There will be 3 new ones:

- local and remote disks with local log
- local and remote disks with remote log
- local and remote disks with mirrored log

==== single log, local log, local disks

I repeated this part, but ideally nothing changed.

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdc /dev/sdd
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 900M -n mymirror -m 1 myvg
  Logical volume "mymirror" created
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

Test results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh

real    0m0.129s
user    0m0.003s
sys     0m0.036s

real    0m0.134s
user    0m0.001s
sys     0m0.036s

real    0m0.071s
user    0m0.002s
sys     0m0.034s
----

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== single log, remote log, local and remote disks

Setup:

- created sdf1 and sdf2 partitions (to make it easy to follow I did not use
  sdg, so that sdf1 and sdf2 are the remote device nodes here as well, just
  like before)
- configured the mirror:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdf2
  No physical volume label read from /dev/sdf1
  Physical volume "/dev/sdf1" successfully created
  No physical volume label read from /dev/sdf2
  Physical volume "/dev/sdf2" successfully created
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 10M -n mymirror -m 1 myvg
  Rounding up size to full physical extent 12.00 MiB
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)
  mymirror            myvg       mwi-a-  12.00m                    mymirror_mlog  33.33         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       Iwi-ao  12.00m                                                 /dev/sdb(0)
  [mymirror_mimage_1] myvg       Iwi-ao  12.00m                                                 /dev/sdf1(0)
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdf2(0)
[root@projlab2 ~]# tail -n 1 /var/log/messages
Oct 30 20:34:31 projlab2 lvm[3487]: myvg-mymirror is now in-sync.
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

I reduced 400M to 10M so that in case it would synchronize the whole contents, it will finish today. ;)

Test results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh

real    0m12.106s
user    0m0.001s
sys     0m0.051s

real    0m12.586s
user    0m0.002s
sys     0m0.058s

real    0m12.784s
user    0m0.000s
sys     0m0.054s
----

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== single log, local log, local and remote disks

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdc
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 10M -n mymirror -m 1 myvg
  Rounding up size to full physical extent 12.00 MiB
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)
  mymirror            myvg       mwi-a-  12.00m                    mymirror_mlog   0.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       Iwi-ao  12.00m                                                 /dev/sdb(0)
  [mymirror_mimage_1] myvg       Iwi-ao  12.00m                                                 /dev/sdf1(0)
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdc(0)
[root@projlab2 ~]# tail -n 1 /var/log/messages
Oct 30 20:41:51 projlab2 lvm[3487]: myvg-mymirror is now in-sync.
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

Test results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh

real    0m11.706s
user    0m0.000s
sys     0m0.050s

real    0m12.996s
user    0m0.001s
sys     0m0.050s

real    0m12.445s
user    0m0.002s
sys     0m0.055s
----

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== mirrored log, local disks

Again, this just just repeated in case something would change in the environment:

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdc /dev/sdd /dev/sde
  /dev/hdc: open failed: Read-only file system
  /dev/hdc: open failed: Read-only file system
  /dev/hdc: open failed: Read-only file system
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 400M -n mymirror -m 1 myvg --mirrorlog mirrored
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                       VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                            
  LogVol00                 VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                                       
  LogVol01                 VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                                     
  mymirror                 myvg       mwi-a- 400.00m                    mymirror_mlog  85.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_0]      myvg       Iwi-ao 400.00m                                                 /dev/sdb(0)                                        
  [mymirror_mimage_1]      myvg       Iwi-ao 400.00m                                                 /dev/sdc(0)                                        
  [mymirror_mlog]          myvg       mwi-ao   4.00m                                  100.00         mymirror_mlog_mimage_0(0),mymirror_mlog_mimage_1(0)
  [mymirror_mlog_mimage_0] myvg       iwi-ao   4.00m                                                 /dev/sdd(0)                                        
  [mymirror_mlog_mimage_1] myvg       iwi-ao   4.00m                                                 /dev/sde(0)
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror 
----

Test results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m2.987s
user    0m0.002s
sys     0m0.050s

real    0m3.146s
user    0m0.003s
sys     0m0.052s

real    0m3.383s
user    0m0.003s
sys     0m0.054s
----

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
----

==== mirrored log, local and remote disks

Setup:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdc /dev/sdf2
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 10M -n mymirror -m 1 myvg --mirrorlog mirrored
  Rounding up size to full physical extent 12.00 MiB
  Logical volume "mymirror" created
[root@projlab2 ~]# lvs -a -o +devices
  LV                       VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                            
  LogVol00                 VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                                       
  LogVol01                 VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                                     
  mymirror                 myvg       mwi-a-  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_0]      myvg       iwi-ao  12.00m                                                 /dev/sdb(0)                                        
  [mymirror_mimage_1]      myvg       iwi-ao  12.00m                                                 /dev/sdf1(0)                                       
  [mymirror_mlog]          myvg       mwi-ao   4.00m                                  100.00         mymirror_mlog_mimage_0(0),mymirror_mlog_mimage_1(0)
  [mymirror_mlog_mimage_0] myvg       iwi-ao   4.00m                                                 /dev/sdc(0)                                        
  [mymirror_mlog_mimage_1] myvg       iwi-ao   4.00m                                                 /dev/sdf2(0)                                       
[root@projlab2 ~]# tail -n 1 /var/log/messages
Oct 30 20:54:17 projlab2 lvm[3487]: myvg-mymirror is now in-sync.
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
----

Test results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh 

real    0m12.337s
user    0m0.000s
sys     0m0.049s

real    0m12.476s
user    0m0.001s
sys     0m0.054s

real    0m12.896s
user    0m0.003s
sys     0m0.047s
----

Tear down:

----
[root@projlab2 ~]# lvchange -a n myvg/mymirror
[root@projlab2 ~]# lvremove myvg/mymirror
  Logical volume "mymirror" successfully removed
[root@projlab2 ~]# vgremove myvg
  Volume group "myvg" successfully removed
[root@projlab2 ~]# /etc/init.d/iscsi stop
Stopping iSCSI daemon: [  OK  ]
----

One problem is that as you can see I got no "logout" message and indeed the sdf
and sdg devices are not removed. After some research I found that I can still
log out manually using:

----
[root@projlab2 ~]# iscsiadm -m node -u
Logging out of session [sid: 1, target: iqn.2010-10.hu.ulx:san.remote, portal: 81.183.209.160,13260]
Logout of [sid: 1, target: iqn.2010-10.hu.ulx:san.remote, portal: 81.183.209.160,13260]: successful
[root@projlab2 ~]# ls /dev/sdg
ls: /dev/sdg: No such file or directory
----

=== Automating the evaluation of measures

The idea is that I have a set of result numbers, like a given configuration
with network delay = 5, 10, 50, 100, 200ms, all measured 3 times. Till now I
just threw these numbers to OOo Calc and exported the chart as eps manually.
In case later more measures will be needed and I'll need more charts, probably
it'll worth to use a dedicated TeX script for this, like
http://www.keithv.com/software/barchart/[this]. For now, I did not replace the
charts I already have with this script.

=== Weighted RR

I ran out of time, so I just write down the userspace interface I imagine for
this feature.

As a reminder, so far we have two commands to change the RR number and set the
default device. Examples:

----
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance round_robin ios 0
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance default 253:3
----

A possible way to tell "use 253:3 and 253:4 with weights 1 and 2" (so that
253:4 will be used twice as 253:3) could be:

----
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance weight 253:3 1
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance weight 253:4 2
----

== 9th week

=== In-person meeting with Akos

We talked about the possible structure of the diploma I'll write in the next
two semesters:

- Introduction:

  * context
  * challenges (examples) / motivation / problems
  * what do we want to solve
  * overview + motivating example (why larger IO throughput is good? for example faster backup, or similar) -> refer to this in every later chapter

- Background

- Implementation

- Measurement (important)

- Conclusion & Future Work

=== In-person meeting with Ivan

- Architecture figure is needed for each LVM setup
- 2nd table: it's not documented if the RR read measure is with delay or not
- What is the connection between network delay (which is probably per-packet) and the data transferred using iSCSI? What amount of real data is in one (probably IP) packet?
- Try out what happens if one disk of a mirror goes away then returns - I only tested when it does not return and it gets replaced with a new disk (local version / iSCSI version - like a network cable cut)
- Conclusion about mirrored log: it worths a note that it may be quite useful in a cluster environment.
- Set up one more WAN iSCSI target, the one on sy.ulx.hu is behind an ADSL, it would be useful to test a target on a faster connection.

Other than these, we scheduled the rest of the semester:

- 9th week: see above
- 10th week: read kernel development documentation, especially about locking (I'm not familiar with those) + see if reads are threaded, otherwise weighted RR won't be faster than simply reading from the fastest device
- 11th week: implement a weighted RR approach
- 12th week: measurement of the above

We also agreed that it's not a must to include the part about weighted RR in
the report of this particular semester, it'll be documented in detail later in
the diploma anyway.

For the last two week:

- 13th week: prepare for the presentation (in-person meeting at ULX to show them first)
- 14th week: presentation at BME

=== Architecture figure for each LVM setup

I added 5 new figure to the report to help understanding the different LVM
setups, even if one is not familiar with the LVM commands.

=== Fix 2nd table

There was a typo on trac and thus in the report: when I measured the read speed
using the default RR approach, then obviously traffic shaping was enabled, not
disabled as I wrote it to trac (and I did not write anything to the report
about the dealy). I corrected this now.

=== Network delay vs. iSCSI

When having 200ms delay / packet, the difference was 18.796 - 1.636 = 17.160s
in the measure.

In case there are no parallel delays, then 17.160s means about 86 packets for
2MB. As a result, 24385 bytes (at a maximum) passed in one IP packet.

According to RFC2625, the maximum IP packet size is 65536 bytes, so this sounds
quite valid. (Not to be confused with MTU, which is about the Ethernet frame
size, that's a lower layer, and there a typical limit is 1500 bytes.)

(Of course iSCSI itself adds some overhead itself, but that's not major, for
example http://www.cs.unh.edu/~rdr/conf_paper_web.htm[this paper] mentions an
overhead of about 15 percent only on 100 MBit, in point 6.4.2.)

=== Transient error of a mirror (goes away then cames back)

Ivan mentioned that when they did experiments with dm-mirror, he remembers when
there was just a transient error (ie. a device failed, then returned) then no
full resync was needed, ie. LVM utilised the log device. I tried this, but it
seems it isn't automated:

- the output of `lvs -a -o +devices` is unchanged when the device node is back

- I need a manual `vgextend` and `lvconvert` to add the device node back

- the `lvconvert` operation is about as IO-intensive (if not more) as the
  mirror creation (by looking at the `iotop` output during the conversion) as
  during the mirror creation, so I'm afraid the log is not utilised at all.

The situation is the same with local and iSCSI device nodes, except:

- local nodes are manually removed and recovered (by writing values to `/sys`)

- iSCSI nodes are automatically removed when the (virtual) network cable is cut
  (+ a timeout is reached), and they are reinserted when the network is back

=== Mirrored log vs. clusters

Improved the conclusion section of the report, mirrored logs still make sense
in cluster environment.

=== One more WAN iSCSI target

I discovered the new target:

----
[root@projlab2 nodes]# iscsiadm --mode discovery --type sendtargets --portal vmiklos.hu
157.181.177.34:3260,1 iqn.2010-11.hu.vmiklos:storage
----

After restarting the client the device node was there:

----
[root@projlab2 nodes]# ls /dev/sdf
ls: /dev/sdf: No such file or directory
[root@projlab2 nodes]# /etc/init.d/iscsi restart
Stopping iSCSI daemon: 
iscsid dead but pid file exists                            [  OK  ]
Starting iSCSI daemon:                                     [  OK  ]
                                                           [  OK  ]
Setting up iSCSI targets: Logging in to [iface: default, target: iqn.2010-11.hu.vmiklos:storage, portal: 157.181.177.34,3260]
Login to [iface: default, target: iqn.2010-11.hu.vmiklos:storage, portal: 157.181.177.34,3260]: successful
                                                           [  OK  ]
[root@projlab2 nodes]# ls /dev/sdf
/dev/sdf
----

At that time I had the following disks:

- sda: local system
- sdb, sdc, sdd, sde: 1G local disks
- sdf: 1G remote disk

Measuring the raw throughput:

----
[root@projlab2 ~]# time sh -c "dd if=/dev/zero of=/mnt/iscsi/test-2mb.img bs=1M count=2; sync" 2>/dev/null

real    0m11.839s
user    0m0.006s
sys     0m0.037s
----

This is almost exactly the same speed as the one I had with `sy.ulx.hu`, which
was 11.648s. :( So, for now I did not repeat the measures as I suppose the
bottleneck at the moment is my network connection at home, so I would get
almost the same results.

== 10th week

=== Measurement with tcpdump

The idea here is to use tcpdump to see the incoming traffic on projlab2 from
iscsitarget and to proof that the elapsed time is relevant, if the per-packet
network delay is 200ms. This should give us better results than just counting
on a paper.

So I configured the mirror to read from the remote leg, enabled 200ms delay and
I ran `tcpdump > log` in an other shell while doing the measurement.

First I checked the size of the incoming traffic (exluding ACK's):

----
[root@projlab2 ~]# grep 'iscsitarget.iscsi-target > projlab2' log|grep -v '\. ack '|sed 's/.*(\(.*\)).*/\1/'|xargs echo|sed 's/ /+/g'|bc
2269008
----

So the traffic from iscsitarget to projlab2 was 2269008 bytes, which is a bit
more than 2MB. The difference is the iSCSI overhead.  Let's check the number of
packages:

----
[root@projlab2 ~]# grep 'iscsitarget.iscsi-target > projlab2' log|grep -v '\. ack '|wc -l
1602
----

Which is much more than the expected 86, so it was a good idea to use tcpdump.

Now in case all these packages are delayed, the total delay would be 320.4
seconds, while it is 17.16. It seems the trick is that only packages with the
PUSH tcp flag are delayed:

----
[root@projlab2 ~]# grep 'iscsitarget.iscsi-target > projlab2' log|grep -v '\. ack '|grep -c ': P '
70
----

That makes sense, since that's the end of logical packets, other packets are
just fragmented, as the size of the IP packets are smaller than the size of the
logical writes.

So ideally the delay would be 70*0.2 = 14s, while the measured delay is
17.160s. The difference is measure error, we already saw above that the
measured times have some dispersion.

=== Changes in the report

- note about tcpdump results
- more description of table 2
- moved patches to the appendix
- removed vg* and lv* commands, they are here in the wiki if someone is interested
- tables now contain measured numbers as well (before average ones), where they were missing previously
- added table showing ratios and physical speeds
- added results of real-life measures
- added a description on why the simulated environment models a real WAN
  properly (to the start of the 'Measurements' section, before the first
  subsection)
- conclusion: added note on how measurement results proof the usefulness of my
  modifications to the dm-mirror driver

=== Validating our model

The idea: let's measure the network ratio and delay of the real-life
environment, set up the simulated environment with the measured parameters and
see if we get similar results. If yes, then this can be a proof on our
simulated environment models the problem well.

The delay:

----
[root@projlab2 ~]# ping -c 3 sy.ulx.hu
PING titan.ulx.hu (81.183.209.160) 56(84) bytes of data.
64 bytes from dsl51B7D1A0.fixip.t-online.hu (81.183.209.160): icmp_seq=1 ttl=128 time=28.8 ms
64 bytes from dsl51B7D1A0.fixip.t-online.hu (81.183.209.160): icmp_seq=2 ttl=128 time=31.2 ms
64 bytes from dsl51B7D1A0.fixip.t-online.hu (81.183.209.160): icmp_seq=3 ttl=128 time=32.1 ms
[root@projlab2 ~]# ping -c 3 iscsitarget
PING iscsitarget (192.168.152.130) 56(84) bytes of data.
64 bytes from iscsitarget (192.168.152.130): icmp_seq=1 ttl=64 time=2.12 ms
64 bytes from iscsitarget (192.168.152.130): icmp_seq=2 ttl=64 time=0.459 ms
64 bytes from iscsitarget (192.168.152.130): icmp_seq=3 ttl=64 time=0.358 ms
----

So the average delay is (28.8+31.2+32.1)/3-(2.12+0.459+0.358)/3 = 29.73ms
(compared to the delay of the other machine, where it should be almost zero).

The ratio:

Writing 2MB of data takes 11.839s (see 8th week): (2*1024*8)/11.839=1383.90
kilobits/s.

This means I'll repeat the measures in the simulated environment with
delay=30ms, ratio=1384kbps:

----
[root@iscsitarget ~]# ./limit.sh start 1384
[root@iscsitarget ~]# ./delay.sh start 30
[root@projlab2 ~]# ping -c 3 iscsitarget
PING iscsitarget (192.168.152.130) 56(84) bytes of data.
64 bytes from iscsitarget (192.168.152.130): icmp_seq=1 ttl=64 time=35.3 ms
64 bytes from iscsitarget (192.168.152.130): icmp_seq=2 ttl=64 time=32.5 ms
64 bytes from iscsitarget (192.168.152.130): icmp_seq=3 ttl=64 time=34.5 ms
----

==== Single log, remote log, local and remote disks

Expected (in seconds): 12.49.

Results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh

real    0m15.006s
user    0m0.004s
sys     0m0.062s

real    0m14.778s
user    0m0.005s
sys     0m0.055s

real    0m14.991s
user    0m0.006s
sys     0m0.052s
----

(15.006+14.778+14.991)/3 = 14.92

==== Single log, local log, local and remote disks

Expected: 12.38.

Results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh

real    0m14.581s
user    0m0.003s
sys     0m0.047s

real    0m14.931s
user    0m0.001s
sys     0m0.053s

real    0m14.717s
user    0m0.004s
sys     0m0.051s
----

(14.581+14.931+14.717)/3 = 14.74

==== Mirrored log, local and remote disks

Expected: 12.56.

Results:

----
[root@projlab2 ~]# ./test-write.sh; ./test-write.sh; ./test-write.sh

real    0m15.071s
user    0m0.002s
sys     0m0.064s

real    0m14.658s
user    0m0.003s
sys     0m0.055s

real    0m14.755s
user    0m0.003s
sys     0m0.053s
----

(15.071+14.658+14.755)/3 = 14.82

To sum up, in each case the simulated environment had an acceptable difference
to the real one, I think.

=== Transient error of a mirror (again)

The question was if it's possible that in some cases when the remote leg goes
away the mirror is not converted to a linear volume.

The answer is definitely yes. What I tried is to have two local legs, and in
that case when I disable one device via sysfs, the mirror is converted to a
linear volume.

What I didn't try is a remote leg (I thought that will be the same): when I
have a remote leg it can recover:

----
[root@projlab2 ~]# lvs -a -o +devices|grep mymirror_mimage_1
  mymirror                 myvg       mwi-a-  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_1]      myvg       iwi-ao  12.00m                                                 /dev/sdg1(0)                                       
[root@projlab2 ~]# /etc/init.d/iscsi stop
Logging out of session [sid: 4, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]
Logout of [sid: 4, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]: successful
Stopping iSCSI daemon:                                     [  OK  ]
[root@projlab2 ~]# lvs -a -o +devices|grep mymirror_mimage_1
  Couldn't find device with uuid GyfMKL-c11n-DUQ8-KRKZ-RW5v-GEN9-aBWy0Z.
  Couldn't find device with uuid z0kSwr-6uPS-A6EK-8oLV-2Bli-N31w-2C08aG.
  mymirror                 myvg       mwi-a-  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_1]      myvg       iwi-ao  12.00m                                                 unknown device(0)                                  
[root@projlab2 ~]# /etc/init.d/iscsi start
iscsid dead but pid file exists
Starting iSCSI daemon:                                     [  OK  ]
Setting up iSCSI targets: Logging in to [iface: default, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]
Login to [iface: default, target: iqn.2008-03.local.virtual2:storage, portal: 192.168.152.130,3260]: successful
[root@projlab2 ~]# lvs -a -o +devices|grep mymirror_mimage_1
  mymirror                 myvg       mwi-a-  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)          
  [mymirror_mimage_1]      myvg       iwi-ao  12.00m                                                 /dev/sdg1(0)
----

=== Future work

Actually I didn't even begin what I planned for today, to read about the
thread-safe data handling API of the kernel, but I ran out of time. In case no
other tasks appear till then, I plan to do it next week.

== 11th week

=== Measurement with tcpdump

The question was: in case `tc` just delays the last physical package of a local
write (the one with a PUSH flag), is this realistic?

I think so, because in reality the fragments of a logical write are sent almost
at the same time, so the delays are parallel. For example in case we send 20
physical fragments, then the real delay will be just a bit more than the delay
for a single package - the key is that we wait for an ACK after the end of a
logical write, but we do not wait for an ACK after sending each fragments.

Additionally, if the delay generated by `tc` would not be realistic, it would
not make any sense. :)

=== Validating our model in a real environment

The request was to repeat our existing read test in a real environment as well.
It seems the remote node (sy.ulx.hu:13260) is no longer accessible, so I used
the other remote box I have access to, as mentioned already on 9th week.

Set up - sdb is the local leg, sde is the remote log, sdc is the local log leg:

----
[root@projlab2 nodes]# iscsiadm --mode discovery --type sendtargets --portal vmiklos.hu
157.181.177.34:3260,1 iqn.2010-11.hu.vmiklos:storage
[root@projlab2 nodes]# ls /dev/sdf
ls: /dev/sdf: No such file or directory
[root@projlab2 nodes]# /etc/init.d/iscsi restart
Stopping iSCSI daemon: 
iscsid dead but pid file exists                            [  OK  ]
Starting iSCSI daemon:
Setting up iSCSI targets: Logging in to [iface: default, target: iqn.2010-11.hu.vmiklos:storage, portal: 157.181.177.34,3260]
Login to [iface: default, target: iqn.2010-11.hu.vmiklos:storage, portal: 157.181.177.34,3260]: successful
                                                           [  OK  ]
[root@projlab2 nodes]# ls /dev/sdf
/dev/sdf
[root@projlab2 nodes]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdc
  No physical volume label read from /dev/sdf1
  Physical volume "/dev/sdf1" successfully created
  Volume group "myvg" successfully created
[root@projlab2 nodes]# lvcreate -L 10M -n mymirror -m 1 myvg
  Rounding up size to full physical extent 12.00 MiB
  Logical volume "mymirror" created
[root@projlab2 nodes]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-a-  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       iwi-ao  12.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       iwi-ao  12.00m                                                 /dev/sdf1(0)                             
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdc(0)
----

Created filesystem and 2MB-sized test file:

----
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror
[root@projlab2 ~]# dd if=/dev/zero of=/mnt/mirror/test bs=1M count=2
2+0 records in
2+0 records out
2097152 bytes (2.1 MB) copied, 0.0195811 seconds, 107 MB/s
[root@projlab2 ~]# umount /mnt/mirror
----

I want to note that umount took some time, since (obviously) the 107MB/s write
speed was a cached one and umount had to write out the cache to the slow remote
device.

Results:

Original RR:

----
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance round_robin ios 128
[root@projlab2 ~]# ./test.sh ; ./test.sh; ./test.sh 

real    0m2.518s
user    0m0.002s
sys     0m0.020s

real    0m0.993s
user    0m0.004s
sys     0m0.028s

real    0m2.049s
user    0m0.000s
sys     0m0.023s
----

(2.518+0.993+2.049)/3=1.85

Forcing local reads:

----
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance round_robin ios 0
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance default 253:3
[root@projlab2 ~]# ./test.sh ; ./test.sh; ./test.sh 

real    0m0.058s
user    0m0.000s
sys     0m0.031s

real    0m0.043s
user    0m0.001s
sys     0m0.030s

real    0m0.044s
user    0m0.000s
sys     0m0.028s
----

(0.058+0.043+0.044)/3=0.04

Forcing remote reads:

----
[root@projlab2 ~]# dmsetup message myvg-mymirror 0 io_balance default 253:4
[root@projlab2 ~]# ./test.sh ; ./test.sh; ./test.sh 

real    0m3.771s
user    0m0.000s
sys     0m0.016s

real    0m3.465s
user    0m0.000s
sys     0m0.017s

real    0m3.349s
user    0m0.001s
sys     0m0.017s
----

(3.771+3.465+3.349)/3=3.52

=== Transient error of a mirror

The request was to check what happens if we do a write or a read after a
recover from a transient error. We want to see if the log is used or not.

Set up:

----
[root@projlab2 ~]# vgcreate myvg /dev/sdb /dev/sdf1 /dev/sdc
  Volume group "myvg" successfully created
[root@projlab2 ~]# lvcreate -L 10M -n mymirror -m 1 myvg
  Rounding up size to full physical extent 12.00 MiB
  Logical volume "mymirror" created
[root@projlab2 ~]# mke2fs -j /dev/myvg/mymirror 
[root@projlab2 ~]# mount /dev/myvg/mymirror /mnt/mirror
[root@projlab2 ~]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-ao  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       iwi-ao  12.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       iwi-ao  12.00m                                                 /dev/sdf1(0)                             
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdc(0)  
----

Inject error by shutting down the iSCSI client:

----
[root@projlab2 ~]# /etc/init.d/iscsi stop
[root@projlab2 ~]# lvs -a -o +devices
  Couldn't find device with uuid GyfMKL-c11n-DUQ8-KRKZ-RW5v-GEN9-aBWy0Z.
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-ao  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       iwi-ao  12.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       iwi-ao  12.00m                                                 unknown device(0)                        
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdc(0)    
----

Recover:

----
[root@projlab2 ~]# /etc/init.d/iscsi start
[root@projlab2 ~]# lvs -a -o +devices
  LV                  VG         Attr   LSize   Origin Snap%  Move Log           Copy%  Convert Devices                                  
  LogVol00            VolGroup00 -wi-ao   7.38g                                                 /dev/sda2(0)                             
  LogVol01            VolGroup00 -wi-ao 512.00m                                                 /dev/sda2(236)                           
  mymirror            myvg       mwi-ao  12.00m                    mymirror_mlog 100.00         mymirror_mimage_0(0),mymirror_mimage_1(0)
  [mymirror_mimage_0] myvg       iwi-ao  12.00m                                                 /dev/sdb(0)                              
  [mymirror_mimage_1] myvg       iwi-ao  12.00m                                                 /dev/sdg1(0)                             
  [mymirror_mlog]     myvg       lwi-ao   4.00m                                                 /dev/sdc(0)       
----

It is unexpected (to me) to see that the recovered device appeared as sdg1, not
sdf1. Performing a read is fine:

----
[root@projlab2 ~]# ls /mnt/mirror/test.img
/mnt/mirror/test.img
----

But performing a write damages the mirror:

----
[root@projlab2 ~]# dd if=/dev/zero of=/mnt/mirror/test.img bs=1M count=2; sync
2+0 records in
2+0 records out
2097152 bytes (2.1 MB) copied, 0.0213064 seconds, 98.4 MB/s
----

No error message here, but if we check the output of `lvs`:

----
[root@projlab2 ~]# lvs -a -o +devices
  LV       VG         Attr   LSize   Origin Snap%  Move Log Copy%  Convert Devices
  LogVol00 VolGroup00 -wi-ao   7.38g                                       /dev/sda2(0)
  LogVol01 VolGroup00 -wi-ao 512.00m                                       /dev/sda2(236)
  mymirror myvg       -wi-ao  12.00m                                       /dev/sdb(0)
----

And `/var/log/messages`:

----
Nov 17 18:21:29 projlab2 lvm[3487]: Secondary mirror device 253:4 has failed (D).
Nov 17 18:21:29 projlab2 lvm[3487]: Device failure in myvg-mymirror.
Nov 17 18:21:29 projlab2 kernel: scsi 26:0:0:1: rejecting I/O to dead device
Nov 17 18:21:29 projlab2 last message repeated 3 times
Nov 17 18:21:29 projlab2 lvm[3487]: Mirror status: 1 of 2 images failed.
Nov 17 18:21:29 projlab2 kernel: scsi 26:0:0:1: rejecting I/O to dead device
Nov 17 18:21:29 projlab2 lvm[3487]: Repair of mirrored LV myvg/mymirror finished successfully.
Nov 17 18:21:31 projlab2 lvm[3487]: No longer monitoring mirror device myvg-mymirror for events.
----

Looks like this is the reason why sdf1 was not re-used: the kernel still stores
that as a (dead) device, and even if the mirror recovers (and sdg is added to
the mirror, according to lvs), the kernel tries to write to sdf, which does not
succeed, and it converts the volume to a linear one. :(

Now this is completely unexpected. I would ask on some LVM developer or user
mailing list if this behaviour known.

=== Moving the results of the real environment to the previous tables

The suggestion was to merge the numbers from sections titled 'Write speed in a
real-life environment' and 'Read speed in real-life environment' to the
previous sections, where simulated results were represented in a tabular
format.

I like the idea of inserting real-life results between simulated ones, but
right now I don't think this is possible. The problem is that I did
measurements with limited bandwidth *or* network delay, but the real-life
environment has limited bandwidth and limited delay as well.

So to make this possible, I would need to measure every combination of network
delays and bandwidth limitations I used. Then the results could be represented
in 3D (delay, bandwidth, measurement result) and one additional item would be
the real-life result.

I think that would be an overkill in this situation (correct me, if I'm wrong).

The same goes to the simulated results. I have the results for 29.73ms delay
and 13834 kbps bandwidth, but I only have other results with a given bandwidth
and no delay or different delays but no bandwidth.

=== Changes in the report

- I wrote a subsection on model validation, based on the wiki contents from
  last week.
- A new subsection on real-life read results.

=== Kernel locking, threaded reading

Earlier, I had the plan to 'read kernel development documentation, especially
about locking (I'm not familiar with those) + see if reads are threaded,
otherwise weighted RR won't be faster than simply reading from the fastest
device'.

First, reads are threaded, or to be more precise, done in an asynchronous way,
so doing a weighted RR will make sense. The async read call is in drivers/md/dm-raid1.c, in function do_reads():

----
read_async_bio(m, bio);
----

Functions which are probably related to threading, but I'm not familiar with:

- atomic_set(), atomic_read()
- likely(), unlikely()

The output of `make htmldocs` is online on kernel.org, so I could find info
about the atomic_* functions
http://www.kernel.org/doc/htmldocs/device-drivers/ch01s02.html[here]. (I don't
want to generate that documentation myself if others already did so.)

Regarding likely/unlikely, I found information
http://stackoverflow.com/questions/109710/likely-unlikely-macros-in-the-linux-kernel[here].
In short: it's just optimization.

=== Future work

Next week I want to extract the RR implementation from
dm-raid1.c::choose_mirror(), so that the user will be able to choose the
algorithm using dmsetup. Once this is done, I could start developing a weighted
RR implementation.
